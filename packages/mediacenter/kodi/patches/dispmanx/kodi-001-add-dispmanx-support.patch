diff --no-dereference -ruN xbmc-20.1-Nexus/addons/resource.language.en_gb/resources/strings.po xbmc-test-Nexus/addons/resource.language.en_gb/resources/strings.po
--- xbmc-20.1-Nexus/addons/resource.language.en_gb/resources/strings.po	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/addons/resource.language.en_gb/resources/strings.po	2023-04-06 14:40:58.658562734 +0000
@@ -7411,7 +7411,12 @@
 msgid "Prefer VAAPI render method"
 msgstr ""
 
-#empty strings from id 13458 to 13459
+#: system/settings/settings.xml
+msgctxt "#13458"
+msgid "Allow Hardware Accelleration with MMAL"
+msgstr ""
+
+#empty string with id 13459
 
 #: system/settings/settings.xml
 msgctxt "#13460"
@@ -9262,7 +9267,7 @@
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16313"
-msgid "VDPAU - Sharpness"
+msgid "Sharpness"
 msgstr ""
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -9371,7 +9376,31 @@
 msgid "IMX - Advanced"
 msgstr ""
 
-#empty strings from id 16337 to 16399
+#. Description of OSD video settings for deinterlace method with label #16337
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16337"
+msgid "MMAL - Advanced"
+msgstr ""
+
+#. Description of OSD video settings for deinterlace method with label #16338
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16338"
+msgid "MMAL - Advanced (half)"
+msgstr ""
+
+#. Description of OSD video settings for deinterlace method with label #16339
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16339"
+msgid "MMAL - Bob"
+msgstr ""
+
+#. Description of OSD video settings for deinterlace method with label #16340
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16340"
+msgid "MMAL - Bob (half)"
+msgstr ""
+
+#empty strings from id 16341 to 16399
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16400"
@@ -20932,7 +20961,18 @@
 msgid "Any repositories"
 msgstr ""
 
-#empty strings from id 36439 to 36441
+#: system/settings/settings.xml
+msgctxt "#36439"
+msgid "Allow using MMAL decoder"
+msgstr ""
+
+#. Description of setting "Allow using MMAL decoder"
+#: system/settings/settings.xml
+msgctxt "#36440"
+msgid "Enable MMAL decoding of video files"
+msgstr ""
+
+#empty string with id 36441
 
 #. Description of setting "System -> Audio output -> Volume control steps" with label #1302
 #: system/settings/settings.xml
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/modules/FindEGL.cmake xbmc-test-Nexus/cmake/modules/FindEGL.cmake
--- xbmc-20.1-Nexus/cmake/modules/FindEGL.cmake	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/cmake/modules/FindEGL.cmake	2023-03-29 12:12:33.000000000 +0000
@@ -15,14 +15,18 @@
 #
 #   EGL::EGL   - The EGL library
 
+if("dmx" IN_LIST CORE_PLATFORM_NAME_LC)
+    set(_brcmprefix brcm)
+endif()
+
 if(PKG_CONFIG_FOUND)
-  pkg_check_modules(PC_EGL egl QUIET)
+  pkg_check_modules(PC_EGL ${_brcmprefix}egl QUIET)
 endif()
 
 find_path(EGL_INCLUDE_DIR EGL/egl.h
                           PATHS ${PC_EGL_INCLUDEDIR})
 
-find_library(EGL_LIBRARY NAMES EGL egl
+find_library(EGL_LIBRARY NAMES ${_brcmprefix}EGL egl
                          PATHS ${PC_EGL_LIBDIR})
 
 set(EGL_VERSION ${PC_EGL_VERSION})
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/modules/FindMMAL.cmake xbmc-test-Nexus/cmake/modules/FindMMAL.cmake
--- xbmc-20.1-Nexus/cmake/modules/FindMMAL.cmake	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/cmake/modules/FindMMAL.cmake	2023-04-06 14:28:32.950445465 +0000
@@ -0,0 +1,53 @@
+# - Try to find MMAL
+# Once done this will define
+#
+# MMAL_FOUND - system has MMAL
+# MMAL_INCLUDE_DIRS - the MMAL include directory
+# MMAL_LIBRARIES - The MMAL libraries
+
+if(PKG_CONFIG_FOUND)
+  pkg_check_modules(PC_MMAL mmal QUIET)
+endif()
+
+
+find_path(MMAL_INCLUDE_DIR NAMES interface/mmal/mmal.h PATHS ${PC_MMAL_INCLUDEDIR})
+find_library(MMAL_LIBRARY NAMES mmal libmmal PATHS ${PC_MMAL_LIBDIR})
+find_library(MMALCORE_LIBRARY NAMES mmal_core libmmal_core PATHS ${PC_MMAL_LIBDIR})
+find_library(MMALUTIL_LIBRARY NAMES mmal_util libmmal_util PATHS ${PC_MMAL_LIBDIR})
+find_library(MMALCLIENT_LIBRARY NAMES mmal_vc_client libmmal_vc_client PATHS ${PC_MMAL_LIBDIR})
+find_library(MMALCOMPONENT_LIBRARY NAMES mmal_components libmmal_components PATHS ${PC_MMAL_LIBDIR})
+find_library(VCHIQ_LIBRARY NAMES vchiq_arm libvchiq_arm PATHS ${PC_MMAL_LIBDIR})
+find_library(VCHOSTIF_LIBRARY NAMES vchostif libvchostif PATHS ${PC_MMAL_LIBDIR})
+find_library(VCILCS_LIBRARY NAMES vcilcs libvcilcs PATHS ${PC_MMAL_LIBDIR})
+find_library(VCOS_LIBRARY NAMES vcos libvcos PATHS ${PC_MMAL_LIBDIR})
+find_library(VCSM_LIBRARY NAMES vcsm libvcsm PATHS ${PC_MMAL_LIBDIR})
+find_library(CONTAINER_LIBRARY NAMES containers libcontainers PATHS ${PC_MMAL_LIBDIR})
+
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(MMAL REQUIRED_VARS MMAL_INCLUDE_DIR
+                                                     MMAL_LIBRARY MMALCORE_LIBRARY MMALUTIL_LIBRARY
+                                                     MMALCLIENT_LIBRARY MMALCOMPONENT_LIBRARY
+                                                     VCHIQ_LIBRARY VCOS_LIBRARY VCSM_LIBRARY VCHOSTIF_LIBRARY
+                                                     VCILCS_LIBRARY CONTAINER_LIBRARY)
+
+
+if(MMAL_FOUND)
+  set(MMAL_INCLUDE_DIRS ${MMAL_INCLUDE_DIR})
+  set(MMAL_LIBRARIES ${MMAL_LIBRARY} ${MMALCORE_LIBRARY} ${MMALUTIL_LIBRARY}
+                     ${MMALCLIENT_LIBRARY} ${MMALCOMPONENT_LIBRARY}
+                     ${VCHIQ_LIBRARY} ${VCOS_LIBRARY} ${VCSM_LIBRARY}
+                     ${VCHOSTIF_LIBRARY} ${VCILCS_LIBRARY} ${CONTAINER_LIBRARY}
+      CACHE STRING "mmal libraries" FORCE)
+  set(MMAL_DEFINITIONS -DHAVE_MMAL=1 -DHAS_MMAL=1 -DHAVE_DMX=1)
+  if(NOT TARGET MMAL::MMAL)
+    add_library(MMAL::MMAL UNKNOWN IMPORTED)
+    set_target_properties(MMAL::MMAL PROPERTIES
+                                     IMPORTED_LOCATION "${MMAL_LIBRARIES}"
+                                     INTERFACE_INCLUDE_DIRECTORIES "${MMAL_INCLUDE_DIR}")
+  endif()
+endif()
+
+mark_as_advanced(MMAL_INCLUDE_DIRS MMAL_LIBRARIES MMAL_DEFINITIONS
+                MMAL_LIBRARY MMALCORE_LIBRARY MMALUTIL_LIBRARY MMALCLIENT_LIBRARY MMALCOMPONENT_LIBRARY
+                VCHIQ_LIBRARY VCOS_LIBRARY VCSM_LIBRARY VCHOSTIF_LIBRARY VCILCS_LIBRARY CONTAINER_LIBRARY)
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/modules/FindOpenGLES.cmake xbmc-test-Nexus/cmake/modules/FindOpenGLES.cmake
--- xbmc-20.1-Nexus/cmake/modules/FindOpenGLES.cmake	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/cmake/modules/FindOpenGLES.cmake	2023-03-29 12:12:33.000000000 +0000
@@ -10,14 +10,18 @@
 # OPENGLES_LIBRARIES - the OpenGLES libraries
 # OPENGLES_DEFINITIONS - the OpenGLES definitions
 
+if("dmx" IN_LIST CORE_PLATFORM_NAME_LC)
+    set(_brcmprefix brcm)
+endif()
+
 if(PKG_CONFIG_FOUND)
-  pkg_check_modules(PC_OPENGLES glesv2 QUIET)
+  pkg_check_modules(PC_OPENGLES ${_brcmprefix}glesv2 QUIET)
 endif()
 
 if(NOT CORE_SYSTEM_NAME STREQUAL darwin_embedded)
   find_path(OPENGLES_INCLUDE_DIR GLES2/gl2.h
                                  PATHS ${PC_OPENGLES_INCLUDEDIR})
-  find_library(OPENGLES_gl_LIBRARY NAMES GLESv2
+  find_library(OPENGLES_gl_LIBRARY NAMES ${_brcmprefix}GLESv2
                                    PATHS ${PC_OPENGLES_LIBDIR})
 else()
   find_library(OPENGLES_gl_LIBRARY NAMES OpenGLES
@@ -27,14 +31,21 @@
   set(OPENGLES_INCLUDE_DIR ${OPENGLES_gl_LIBRARY}/Headers)
 endif()
 
-find_path(OPENGLES3_INCLUDE_DIR GLES3/gl3.h)
-
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(OpenGLES
-                                  REQUIRED_VARS OPENGLES_gl_LIBRARY OPENGLES_INCLUDE_DIR)
-
-find_path(OPENGLES3_INCLUDE_DIR GLES3/gl3.h
-                                PATHS ${PC_OPENGLES_INCLUDEDIR})
+if("dmx" IN_LIST CORE_PLATFORM_NAME_LC)
+  find_path(OPENGLES_INCLUDE_DIR GLES2/gl2.h)
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(OpenGLES
+                                    REQUIRED_VARS OPENGLES_gl_LIBRARY OPENGLES_INCLUDE_DIR)
+  find_path(OPENGLES_INCLUDE_DIR GLES2/gl2.h
+                                  PATHS ${PC_OPENGLES_INCLUDEDIR})
+else()
+  find_path(OPENGLES3_INCLUDE_DIR GLES3/gl3.h)
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(OpenGLES
+                                    REQUIRED_VARS OPENGLES_gl_LIBRARY OPENGLES_INCLUDE_DIR)
+  find_path(OPENGLES3_INCLUDE_DIR GLES3/gl3.h
+                                  PATHS ${PC_OPENGLES_INCLUDEDIR})
+endif()
 
 if(OPENGLES_FOUND)
   set(OPENGLES_LIBRARIES ${OPENGLES_gl_LIBRARY})
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/platform/freebsd/dmx.cmake xbmc-test-Nexus/cmake/platform/freebsd/dmx.cmake
--- xbmc-20.1-Nexus/cmake/platform/freebsd/dmx.cmake	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/cmake/platform/freebsd/dmx.cmake	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1 @@
+include(cmake/platform/linux/dmx.cmake)
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/platform/linux/dmx.cmake xbmc-test-Nexus/cmake/platform/linux/dmx.cmake
--- xbmc-20.1-Nexus/cmake/platform/linux/dmx.cmake	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/cmake/platform/linux/dmx.cmake	2023-04-06 12:32:25.000000000 +0000
@@ -0,0 +1,8 @@
+set(PLATFORM_REQUIRED_DEPS EGL MMAL LibInput Xkbcommon)
+
+if(APP_RENDER_SYSTEM STREQUAL "gl")
+  list(APPEND PLATFORM_REQUIRED_DEPS OpenGl)
+elseif(APP_RENDER_SYSTEM STREQUAL "gles")
+  list(APPEND PLATFORM_REQUIRED_DEPS OpenGLES)
+endif()
+
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/scripts/linux/ArchSetup.cmake xbmc-test-Nexus/cmake/scripts/linux/ArchSetup.cmake
--- xbmc-20.1-Nexus/cmake/scripts/linux/ArchSetup.cmake	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/cmake/scripts/linux/ArchSetup.cmake	2023-03-29 12:12:33.000000000 +0000
@@ -26,11 +26,11 @@
   elseif(CPU MATCHES "cortex-a7")
     set(ARCH arm)
     set(NEON True)
-    set(NEON_FLAGS "-fPIC -mcpu=cortex-a7")
+    set(NEON_FLAGS "-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4 -mvectorize-with-neon-quad")
   elseif(CPU MATCHES "cortex-a53")
     set(ARCH arm)
     set(NEON True)
-    set(NEON_FLAGS "-fPIC -mcpu=cortex-a53")
+    set(NEON_FLAGS "-fPIC -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=neon-fp-armv8 -mvectorize-with-neon-quad")
   elseif(CPU MATCHES arm)
     set(ARCH arm)
     set(NEON True)
diff --no-dereference -ruN xbmc-20.1-Nexus/cmake/treedata/common/dmx/dmx.txt xbmc-test-Nexus/cmake/treedata/common/dmx/dmx.txt
--- xbmc-20.1-Nexus/cmake/treedata/common/dmx/dmx.txt	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/cmake/treedata/common/dmx/dmx.txt	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,3 @@
+xbmc/cores/RetroPlayer/process/dmx cores/RetroPlayer/process/dmx
+xbmc/cores/VideoPlayer/Process/dmx cores/VideoPlayer/Process/dmx
+xbmc/windowing/dmx windowing/dmx
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/system/settings/linux.xml xbmc-test-Nexus/system/settings/linux.xml
--- xbmc-20.1-Nexus/system/settings/linux.xml	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/system/settings/linux.xml	2023-04-06 15:04:08.950974519 +0000
@@ -193,6 +193,39 @@
           </constraints>
           <control type="spinner" format="string" />
         </setting>
+        <setting id="videoplayer.usemmaldecoder" type="boolean" label="36439" help="36440">
+          <requirement>HAVE_MMAL</requirement>
+          <visible>false</visible>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoplayer.usemmaldecoderforhw" type="boolean" parent="videoplayer.usemmaldecoder" label="13458">
+          <requirement>HAVE_MMAL</requirement>
+          <visible>false</visible>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.usemmaldecoder" operator="is">true</condition>
+            </dependency>
+          </dependencies>
+          <level>3</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoplayer.limitguiupdate" type="integer" label="38013" help="38014">
+          <requirement>HAVE_MMAL</requirement>
+          <level>2</level>
+          <default>10</default>
+          <constraints>
+            <minimum label="38015">0</minimum> <!-- Unlimited -->
+            <step>5</step>
+            <maximum>30</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38016</formatlabel>
+          </control>
+          <control type="edit" format="integer" />
+        </setting>
       </group>
     </category>
   </section>
diff --no-dereference -ruN xbmc-20.1-Nexus/system/settings/settings.xml xbmc-test-Nexus/system/settings/settings.xml
--- xbmc-20.1-Nexus/system/settings/settings.xml	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/system/settings/settings.xml	2023-03-29 15:47:15.000000000 +0000
@@ -2517,6 +2517,7 @@
               <condition>HAS_DX</condition>
               <condition>HAVE_IOS</condition>
               <condition>HAVE_GBM</condition>
+              <condition>HAVE_DMX</condition>
             </or>
           </requirement>
           <level>0</level>
diff --no-dereference -ruN xbmc-20.1-Nexus/tools/depends/target/Toolchain_binaddons.cmake.in xbmc-test-Nexus/tools/depends/target/Toolchain_binaddons.cmake.in
--- xbmc-20.1-Nexus/tools/depends/target/Toolchain_binaddons.cmake.in	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/tools/depends/target/Toolchain_binaddons.cmake.in	2023-03-29 12:12:33.000000000 +0000
@@ -66,6 +66,13 @@
   list(APPEND CMAKE_FIND_ROOT_PATH @use_toolchain@/sysroot/usr)
 endif()
 
+# add broadcom firmware directories
+if(CORE_PLATFORM_NAME STREQUAL dmx)
+  list(APPEND CMAKE_FIND_ROOT_PATH @use_firmware@/opt/vc)
+  list(APPEND CMAKE_LIBRARY_PATH @CMAKE_FIND_ROOT_PATH@/lib:@use_firmware@/opt/vc/lib)
+  list(APPEND CMAKE_INCLUDE_PATH @CMAKE_FIND_ROOT_PATH@/include:@use_firmware@/opt/vc/include)
+endif()
+
 # add Android directories and tools
 if(CORE_SYSTEM_NAME STREQUAL android)
   set(NDKROOT @use_ndk_path@)
diff --no-dereference -ruN xbmc-20.1-Nexus/tools/depends/target/Toolchain.cmake.in xbmc-test-Nexus/tools/depends/target/Toolchain.cmake.in
--- xbmc-20.1-Nexus/tools/depends/target/Toolchain.cmake.in	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/tools/depends/target/Toolchain.cmake.in	2023-03-29 12:12:33.000000000 +0000
@@ -85,6 +85,13 @@
   list(APPEND CMAKE_FIND_ROOT_PATH @use_sdk_path@ @use_sdk_path@/usr)
 endif()
 
+# add broadcom firmware directories
+if(CORE_PLATFORM_NAME STREQUAL dmx)
+  list(APPEND CMAKE_FIND_ROOT_PATH @use_firmware@/opt/vc)
+  list(APPEND CMAKE_LIBRARY_PATH @use_firmware@/opt/vc/lib)
+  list(APPEND CMAKE_INCLUDE_PATH @use_firmware@/opt/vc/include)
+endif()
+
 # add Android directories and tools
 if(CORE_SYSTEM_NAME STREQUAL android)
   set(NDKROOT @use_ndk_path@)
diff --no-dereference -ruN xbmc-20.1-Nexus/.vscode/c_cpp_properties.json xbmc-test-Nexus/.vscode/c_cpp_properties.json
--- xbmc-20.1-Nexus/.vscode/c_cpp_properties.json	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/.vscode/c_cpp_properties.json	2023-04-05 16:30:03.000000000 +0000
@@ -0,0 +1,26 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "forcedInclude": [],
+            "includePath": [
+                "${workspaceFolder}",
+                "${workspaceFolder}/lib",
+                "${workspaceFolder}/xbmc/**",
+                "${workspaceFolder}/xbmc/platform/linux",
+                "${workspaceFolder}/xbmc/platform/posix",
+                "/home/rada/projects/libreelec/LibreELEC/build.LibreELEC-RPi3.arm-11.0.1/toolchain/include/**",
+                "/home/rada/projects/libreelec/LibreELEC/build.LibreELEC-RPi3.arm-11.0.1/build/spdlog-1.11.0/include",
+                "/home/rada/projects/libreelec/LibreELEC/build.LibreELEC-RPi3.arm-11.0.1/toolchain/x86_64-linux-gnu/armv8a-libreelec-linux-gnueabihf/include"
+            ],
+            "defines": ["HAVE_DMX", "HAVE_MMAL", "HAS_GLES=2", "HAVE_GLES", "TARGET_LINUX", "TARGET_POSIX", "__VIDEOCORE__"],
+            "compilerPath": "/home/rada/projects/libreelec/LibreELEC/build.LibreELEC-RPi3.arm-11.0.1/toolchain/bin/armv8a-libreelec-linux-gnueabihf-g++",
+            "cStandard": "c17",
+            "cppStandard": "c++14",
+            "intelliSenseMode": "linux-gcc-arm",
+            "configurationProvider": "ms-vscode.makefile-tools"
+
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/.vscode/settings.json xbmc-test-Nexus/.vscode/settings.json
--- xbmc-20.1-Nexus/.vscode/settings.json	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/.vscode/settings.json	2023-04-05 16:44:01.000000000 +0000
@@ -0,0 +1,99 @@
+{
+  "files.associations": {
+    "array": "cpp",
+    "atomic": "cpp",
+    "bit": "cpp",
+    "*.tcc": "cpp",
+    "cctype": "cpp",
+    "charconv": "cpp",
+    "chrono": "cpp",
+    "clocale": "cpp",
+    "cmath": "cpp",
+    "compare": "cpp",
+    "concepts": "cpp",
+    "condition_variable": "cpp",
+    "cstdarg": "cpp",
+    "cstddef": "cpp",
+    "cstdint": "cpp",
+    "cstdio": "cpp",
+    "cstdlib": "cpp",
+    "cstring": "cpp",
+    "ctime": "cpp",
+    "cwchar": "cpp",
+    "cwctype": "cpp",
+    "deque": "cpp",
+    "list": "cpp",
+    "map": "cpp",
+    "set": "cpp",
+    "unordered_map": "cpp",
+    "vector": "cpp",
+    "exception": "cpp",
+    "string_view": "cpp",
+    "functional": "cpp",
+    "future": "cpp",
+    "initializer_list": "cpp",
+    "iosfwd": "cpp",
+    "iostream": "cpp",
+    "istream": "cpp",
+    "limits": "cpp",
+    "memory": "cpp",
+    "mutex": "cpp",
+    "new": "cpp",
+    "optional": "cpp",
+    "ostream": "cpp",
+    "ranges": "cpp",
+    "ratio": "cpp",
+    "sstream": "cpp",
+    "stdexcept": "cpp",
+    "stop_token": "cpp",
+    "streambuf": "cpp",
+    "string": "cpp",
+    "system_error": "cpp",
+    "thread": "cpp",
+    "type_traits": "cpp",
+    "tuple": "cpp",
+    "typeinfo": "cpp",
+    "utility": "cpp",
+    "dma-buf.h": "c",
+    "vchost_config.h": "c",
+    "regex": "cpp",
+    "strstream": "cpp",
+    "bitset": "cpp",
+    "cinttypes": "cpp",
+    "unordered_set": "cpp",
+    "algorithm": "cpp",
+    "iterator": "cpp",
+    "memory_resource": "cpp",
+    "numeric": "cpp",
+    "random": "cpp",
+    "fstream": "cpp",
+    "iomanip": "cpp",
+    "shared_mutex": "cpp",
+    "typeindex": "cpp",
+    "numbers": "cpp",
+    "semaphore": "cpp",
+    "span": "cpp"
+  },
+  "C_Cpp.codeAnalysis.clangTidy.enabled": false,
+  "C_Cpp.clang_format_style": "file",
+  "C_Cpp.clang_format_path": "/usr/bin/clang-format",
+  "C_Cpp.codeAnalysis.clangTidy.config": "",
+  "C_Cpp.codeAnalysis.clangTidy.headerFilter": "(^|/)(tools|xbmc)/",
+  "C_Cpp.codeAnalysis.clangTidy.checks.enabled": [
+    "performance-faster-string-find",
+    "performance-for-range-copy",
+    "performance-implicit-conversion-in-loop",
+    "performance-inefficient-algorithm",
+    "performance-inefficient-vector-operation",
+    "performance-move-const-arg",
+    "performance-move-constructor-init",
+    "performance-no-automatic-move",
+    "performance-noexcept-move-constructor",
+    "performance-trivially-destructible",
+    "performance-type-promotion-in-math-fn",
+    "performance-unnecessary-copy-initialization",
+    "performance-unnecessary-value-param"
+  ],
+  "C_Cpp.codeAnalysis.clangTidy.path": "/usr/bin/clang-tidy",
+  "C_Cpp.codeAnalysis.clangTidy.useBuildPath": false,
+}
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/application/Application.cpp xbmc-test-Nexus/xbmc/application/Application.cpp
--- xbmc-20.1-Nexus/xbmc/application/Application.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/application/Application.cpp	2023-04-06 12:34:27.000000000 +0000
@@ -1839,21 +1839,20 @@
   {
     m_skipGuiRender = false;
 
-    /*! @todo look into the possibility to use this for GBM
-    int fps = 0;
-
-    // This code reduces rendering fps of the GUI layer when playing videos in fullscreen mode
-    // it makes only sense on architectures with multiple layers
-    if (CServiceBroker::GetWinSystem()->GetGfxContext().IsFullScreenVideo() && !m_appPlayer.IsPausedPlayback() && m_appPlayer.IsRenderingVideoLayer())
-      fps = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE);
-
-    auto now = std::chrono::steady_clock::now();
-
-    auto frameTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_lastRenderTime).count();
-    if (fps > 0 && frameTime * fps < 1000)
-      m_skipGuiRender = true;
-    */
-
+#if defined(HAVE_DMX)
+    if (appPlayer->IsPlayingVideo() && !appPlayer->IsPausedPlayback() && appPlayer->IsRenderingVideoLayer())
+    {
+      int fps = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE);
+      if(fps > 0)
+      {
+        auto now = std::chrono::steady_clock::now();
+        auto frameTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_lastRenderTime).count();
+        if (frameTime * fps < 1000)
+          m_skipGuiRender = true;
+      }
+    }
+#endif
+ 
     if (CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_guiSmartRedraw && m_guiRefreshTimer.IsTimePast())
     {
       CServiceBroker::GetGUI()->GetWindowManager().SendMessage(GUI_MSG_REFRESH_TIMER, 0, 0);
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp xbmc-test-Nexus/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp
--- xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp	2023-04-01 23:54:15.000000000 +0000
@@ -71,22 +71,22 @@
       glTexSubImage2D(m_textureTarget, 0, 0, y, m_width, 1, m_pixelformat, m_pixeltype, pixels);
     }
   }
+#ifdef GL_UNPACK_ROW_LENGTH_EXT
   else if (m_context.IsExtSupported("GL_EXT_unpack_subimage"))
   {
-#ifdef GL_UNPACK_ROW_LENGTH_EXT
     glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, stride / m_bpp);
     glTexSubImage2D(m_textureTarget, 0, 0, 0, m_width, m_height, m_pixelformat, m_pixeltype,
                     m_data.data());
     glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, 0);
-#endif
   }
+#else
   else
   {
     uint8_t* pixels = const_cast<uint8_t*>(m_data.data());
     for (unsigned int y = 0; y < m_height; ++y, pixels += stride)
       glTexSubImage2D(m_textureTarget, 0, 0, y, m_width, 1, m_pixelformat, m_pixeltype, pixels);
   }
-
+#endif
   glBindTexture(m_textureTarget, 0);
 
   return true;
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/CMakeLists.txt	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,4 @@
+set(SOURCES RPProcessInfoDmx.cpp)
+set(HEADERS RPProcessInfoDmx.h)
+
+core_add_library(rp-process-dmx)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.cpp xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.cpp
--- xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RPProcessInfoDmx.h"
+
+using namespace KODI;
+using namespace RETRO;
+
+CRPProcessInfoDmx::CRPProcessInfoDmx() : CRPProcessInfo("DMX")
+{
+}
+
+CRPProcessInfo* CRPProcessInfoDmx::Create()
+{
+  return new CRPProcessInfoDmx();
+}
+
+void CRPProcessInfoDmx::Register()
+{
+  CRPProcessInfo::RegisterProcessControl(CRPProcessInfoDmx::Create);
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.h xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.h
--- xbmc-20.1-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/RetroPlayer/process/dmx/RPProcessInfoDmx.h	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/RetroPlayer/process/RPProcessInfo.h"
+
+namespace KODI
+{
+namespace RETRO
+{
+class CRPProcessInfoDmx : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoDmx();
+
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -10,4 +10,11 @@
                       VideoBufferPoolDMA.h)
 endif()
 
+if(MMAL_FOUND)
+  list(APPEND SOURCES VideoBufferMMAL.cpp
+                      VideoBufferPoolMMAL.cpp)
+  list(APPEND HEADERS VideoBufferMMAL.h
+                      VideoBufferPoolMMAL.h)
+endif()
+
 core_add_library(videoplayer-buffers)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -29,7 +29,7 @@
 
 void CVideoBuffer::Acquire(std::shared_ptr<IVideoBufferPool> pool)
 {
-  m_refCount++;
+  Acquire();
   m_pool = std::move(pool);
 }
 
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.h	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBuffer.h	2023-03-29 12:12:33.000000000 +0000
@@ -87,9 +87,9 @@
 public:
   CVideoBuffer() = delete;
   virtual ~CVideoBuffer() = default;
-  void Acquire();
-  void Acquire(std::shared_ptr<IVideoBufferPool> pool);
-  void Release();
+  virtual void Acquire();
+  virtual void Acquire(std::shared_ptr<IVideoBufferPool> pool);
+  virtual void Release();
   int GetId() const { return m_id; }
 
   virtual AVPixelFormat GetFormat();
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.cpp	2023-04-09 15:55:50.124417063 +0000
@@ -0,0 +1,398 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoBufferMMAL.h"
+
+#include "ServiceBroker.h"
+#include "VideoBufferPoolMMAL.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "windowing/dmx/WinSystemDmx.h"
+
+#include <interface/mmal/core/mmal_buffer_private.h>
+#include <interface/vcsm/user-vcsm.h>
+
+extern "C"
+{
+#include <libavcodec/avcodec.h>
+#include <libavutil/imgutils.h>
+#include <libavutil/pixdesc.h>
+}
+
+using namespace MMAL;
+
+CVideoBufferMMAL::CVideoBufferMMAL(int id, MMALBufferHeader header) : CVideoBuffer(id)
+{
+  m_pixFormat = AV_PIX_FMT_NONE;
+  m_pool = nullptr;
+  m_header = header;
+  m_header->user_data = this;
+  m_refCount = 0;
+  m_refPtr = nullptr;
+}
+
+CVideoBufferMMAL::~CVideoBufferMMAL()
+{
+  CLog::Log(LOGDEBUG, "CVideoBufferMMAL::{} - destroying buffer {}", __FUNCTION__, m_id);
+  m_refCount = 0;
+  Dispose();
+  CLog::Log(LOGDEBUG, "CVideoBufferMMAL::{} - destroyed buffer {}", __FUNCTION__, m_id);
+}
+
+void CVideoBufferMMAL::Dispose()
+{
+  std::unique_lock<CCriticalSection> lock(m_critSection);
+  if (m_header)
+  {
+    if (m_refCount <= 0)
+    {
+      m_header->priv->owner = nullptr;
+      m_header->priv->pre_release_userdata = nullptr;
+      m_header->priv->pf_pre_release = nullptr;
+      m_header->priv->pf_release = nullptr;
+
+      if (m_picture.videoBuffer)
+        m_picture.videoBuffer = nullptr;
+
+      if (m_refPtr)
+      {
+        mmal_buffer_header_reset(m_header);
+        m_header->cmd = 0;
+        m_header->flags = 0;
+        m_header->data = (uint8_t*)-1;
+        m_header->offset = 0;
+        m_header->length = 0;
+        m_header->alloc_size = 0;
+        m_header->dts = MMAL_TIME_UNKNOWN;
+        m_header->pts = MMAL_TIME_UNKNOWN;
+
+        av_mmal_zc_unref(m_refPtr);
+        m_refPtr = nullptr;
+
+        m_header->user_data = nullptr;
+        m_header->priv->refcount = 0;
+      }
+      else
+      {
+        if (m_locked)
+          mmal_buffer_header_mem_unlock(m_header);
+        m_header->user_data = nullptr;
+        m_header->priv->refcount = 0;
+        m_header->priv->reference = nullptr;
+        if (m_header->priv->payload != nullptr)
+          mmal_port_payload_free((MMALPort)m_header->priv->payload_context,
+                                 (uint8_t*)m_header->priv->payload);
+      }
+      vcos_free(m_header);
+      m_portFormat = nullptr;
+      m_header = nullptr;
+      m_pool = nullptr;
+    }
+  }
+  m_disposing = true;
+}
+
+void CVideoBufferMMAL::Acquire()
+{
+  Acquire(true);
+}
+
+void CVideoBufferMMAL::Acquire(bool lockMemory)
+{
+  std::unique_lock<CCriticalSection> lock(m_critSection);
+  mmal_buffer_header_acquire(m_header);
+  m_refCount = m_header->priv->refcount;
+  if (lockMemory && !m_locked)
+    m_locked = mmal_buffer_header_mem_lock(m_header) == MMAL_SUCCESS;
+
+  int64_t dtsPicture = MMAL_TIME_UNKNOWN;
+  int64_t ptsPicture = MMAL_TIME_UNKNOWN;
+
+  if (m_picture.dts != DVD_NOPTS_VALUE)
+    dtsPicture = static_cast<int64_t>(m_picture.dts / DVD_TIME_BASE * AV_TIME_BASE);
+  if (m_picture.pts != DVD_NOPTS_VALUE)
+    ptsPicture = static_cast<int64_t>(m_picture.pts / DVD_TIME_BASE * AV_TIME_BASE);
+
+  if (dtsPicture != MMAL_TIME_UNKNOWN)
+    m_header->dts = dtsPicture;
+  if (ptsPicture != MMAL_TIME_UNKNOWN)
+    m_header->pts = ptsPicture;
+
+  if ((m_picture.iFlags & DVP_FLAG_DROPPED) != 0 &&
+      (m_header->flags & MMAL_BUFFER_HEADER_FLAG_DROPPED) == 0)
+    m_header->flags |= MMAL_BUFFER_HEADER_FLAG_DROPPED;
+}
+
+void CVideoBufferMMAL::Acquire(std::shared_ptr<IVideoBufferPool> pool)
+{
+  std::unique_lock<CCriticalSection> lock(m_critSection);
+  if (m_pool)
+    m_pool = nullptr;
+
+  m_refCount = m_header->priv->refcount;
+  m_pool = std::move(pool);
+
+  if (m_header->pts == MMAL_TIME_UNKNOWN)
+    m_picture.pts = DVD_NOPTS_VALUE;
+  else
+    m_picture.pts = static_cast<double>(m_header->pts) * DVD_TIME_BASE / AV_TIME_BASE;
+
+  if (m_header->dts == MMAL_TIME_UNKNOWN)
+    m_picture.dts = DVD_NOPTS_VALUE;
+  else
+    m_picture.dts = static_cast<double>(m_header->dts) * DVD_TIME_BASE / AV_TIME_BASE;
+
+  m_picture.iFlags = 0;
+  if ((m_header->flags & MMAL_BUFFER_HEADER_FLAG_DROPPED) != 0)
+    m_picture.iFlags |= DVP_FLAG_DROPPED;
+
+  if ((m_header->flags & MMAL_BUFFER_HEADER_FLAG_SEEK) != 0)
+  {
+    m_picture.iFlags &= ~MMAL_BUFFER_HEADER_FLAG_SEEK;
+    m_picture.iFlags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
+  }
+}
+
+void CVideoBufferMMAL::Release()
+{
+  std::unique_lock<CCriticalSection> lock(m_critSection);
+  if (m_disposing)
+  {
+    --m_refCount;
+    Dispose();
+  }
+  else
+  {
+    m_refCount = m_header->priv->refcount;
+    if (--m_refCount <= 0)
+    {
+      if (m_picture.videoBuffer)
+        m_picture.videoBuffer = nullptr;
+
+      if (m_refPtr)
+      {
+        av_mmal_zc_unref(m_refPtr);
+        m_refPtr = nullptr;
+      }
+
+      if (m_refCount != 0)
+        m_refCount = 0;
+      else
+      {
+        if (m_locked)
+        {
+          mmal_buffer_header_mem_unlock(m_header);
+          m_locked = false;
+        }
+        mmal_buffer_header_release(m_header);
+      }
+
+      if (m_pool)
+        m_pool = nullptr;
+    }
+    else
+    {
+      mmal_buffer_header_release(m_header);
+    }
+  }
+}
+
+void CVideoBufferMMAL::SetBasePicture(VideoPicture* pBasePicture)
+{
+  memcpy(&m_picture, pBasePicture, sizeof(VideoPicture));
+}
+
+void CVideoBufferMMAL::GetPlanes(uint8_t* (&planes)[YuvImage::MAX_PLANES])
+{
+  for (uint32_t i = 0; i < YuvImage::MAX_PLANES; i++)
+    planes[i] = m_header->data + m_header->type->video.offset[i];
+}
+
+void CVideoBufferMMAL::GetStrides(int (&strides)[YuvImage::MAX_PLANES])
+{
+  for (uint32_t i = 0; i < YuvImage::MAX_PLANES; i++)
+    strides[i] = m_header->type->video.pitch[i];
+}
+
+void CVideoBufferMMAL::SetDimensions(int width, int height)
+{
+  int strides[YuvImage::MAX_PLANES];
+  for (uint32_t i = 0; i < m_header->type->video.planes; i++)
+  {
+    strides[i] = m_header->type->video.pitch[i];
+  }
+  SetDimensions(width, height, strides);
+}
+
+void CVideoBufferMMAL::SetDimensions(int width,
+                                     int height,
+                                     const int (&strides)[YuvImage::MAX_PLANES])
+{
+  int planeOffsets[YuvImage::MAX_PLANES];
+  for (uint32_t i = 0; i < m_header->type->video.planes; i++)
+  {
+    planeOffsets[i] = m_header->type->video.offset[i];
+  }
+  SetDimensions(width, height, strides, planeOffsets);
+}
+
+void CVideoBufferMMAL::SetDimensions(int width,
+                                     int height,
+                                     const int (&strides)[YuvImage::MAX_PLANES],
+                                     const int (&planeOffsets)[YuvImage::MAX_PLANES])
+{
+  m_picture.iWidth = width;
+  m_picture.iHeight = height;
+
+  for (uint32_t i = 0; i < m_header->type->video.planes; i++)
+  {
+    m_header->type->video.offset[i] = planeOffsets[i];
+    m_header->type->video.pitch[i] = strides[i];
+  }
+}
+
+uint8_t* CVideoBufferMMAL::GetMemPtr()
+{
+  return m_header->data;
+}
+
+int CVideoBufferMMAL::GetRenderIndex()
+{
+  return m_renderIndex;
+}
+
+void CVideoBufferMMAL::SetRenderIndex(int renderIndex)
+{
+  m_renderIndex = renderIndex;
+}
+
+MMALFormat CVideoBufferMMAL::GetPortFormat()
+{
+  return m_portFormat;
+}
+
+void CVideoBufferMMAL::SetPortFormat(MMALFormat portFormat)
+{
+  m_portFormat = portFormat;
+  m_pixFormat = CVideoBufferPoolMMAL::TranslatePortFormat(portFormat->encoding);
+}
+
+void CVideoBufferMMAL::ReleasePtr()
+{
+  if (m_refPtr)
+  {
+    av_mmal_zc_unref(m_refPtr);
+    m_refPtr = nullptr;
+  }
+}
+
+bool CVideoBufferMMAL::UpdateBufferFromFrame(AVFrame* frame,
+                                             AVCodecID codecId,
+                                             bool flushed,
+                                             AVZcEnvPtr envPtr)
+{
+  if (codecId == AV_CODEC_ID_HEVC)
+  {
+    if (m_refPtr)
+    {
+      av_mmal_zc_unref(m_refPtr);
+      m_refPtr = nullptr;
+    }
+
+    if (frame == nullptr || frame->buf[0] == nullptr || av_mmal_zc_vc_handle(frame->buf[0]) == -1)
+    {
+      mmal_buffer_header_reset(m_header);
+      m_header->cmd = 0;
+      m_header->flags = MMAL_BUFFER_HEADER_FLAG_FRAME_END | MMAL_BUFFER_HEADER_FLAG_DROPPED;
+      m_header->data = (uint8_t*)-1;
+      m_header->offset = 0;
+      m_header->length = 0;
+      m_header->alloc_size = 0;
+      m_header->dts = MMAL_TIME_UNKNOWN;
+      m_header->pts = MMAL_TIME_UNKNOWN;
+    }
+    else
+    {
+      m_refPtr = av_mmal_zc_ref(envPtr, frame, (AVPixelFormat)frame->format, 1);
+      mmal_buffer_header_reset(m_header);
+      m_header->cmd = 0;
+      m_header->flags = MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+      m_header->data = (uint8_t*)av_mmal_zc_vc_handle(m_refPtr);
+      m_header->offset = av_mmal_zc_offset(m_refPtr);
+      m_header->length = av_mmal_zc_length(m_refPtr);
+      m_header->alloc_size = av_mmal_zc_numbytes(m_refPtr);
+      m_header->dts = MMAL_TIME_UNKNOWN;
+      m_header->pts = MMAL_TIME_UNKNOWN;
+
+      if (frame->pts != AV_NOPTS_VALUE)
+        m_header->pts = frame->pts;
+
+      if (frame->pkt_dts != AV_NOPTS_VALUE)
+        m_header->dts = frame->pkt_dts;
+
+      if (flushed)
+        m_header->flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
+    }
+    return true;
+  }
+  else
+  {
+    if (frame == nullptr)
+    {
+      mmal_buffer_header_reset(m_header);
+      m_header->cmd = 0;
+      m_header->flags = MMAL_BUFFER_HEADER_FLAG_FRAME_END | MMAL_BUFFER_HEADER_FLAG_DROPPED;
+      m_header->length = 0;
+      m_header->dts = MMAL_TIME_UNKNOWN;
+      m_header->pts = MMAL_TIME_UNKNOWN;
+    }
+    else
+    {
+      mmal_buffer_header_reset(m_header);
+      m_header->cmd = 0;
+      m_header->flags = MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+      if (!m_locked)
+        m_locked = mmal_buffer_header_mem_lock(m_header) == MMAL_SUCCESS;
+      if (m_locked)
+      {
+        m_header->length = av_image_copy_to_buffer(
+            m_header->data, m_header->alloc_size, frame->data, frame->linesize,
+            (AVPixelFormat)frame->format, VCOS_ALIGN_UP(frame->width, 32),
+            VCOS_ALIGN_UP(frame->height, 16), 1);
+        mmal_buffer_header_mem_unlock(m_header);
+        m_locked = false;
+        m_header->type->video.planes = YuvImage::MAX_PLANES;
+
+        for (uint32_t i = 0; i < m_header->type->video.planes; i++)
+        {
+          if (i == 0)
+            m_header->type->video.offset[i] = 0;
+          else
+            m_header->type->video.offset[i] =
+                m_header->type->video.offset[i - 1] + m_header->type->video.pitch[i - 1];
+
+          m_header->type->video.pitch[i] = frame->linesize[i];
+        }
+      }
+
+      m_header->dts = MMAL_TIME_UNKNOWN;
+      m_header->pts = MMAL_TIME_UNKNOWN;
+
+      if (frame->pts != AV_NOPTS_VALUE)
+        m_header->pts = frame->pts;
+
+      if (frame->pkt_dts != AV_NOPTS_VALUE)
+        m_header->dts = frame->pkt_dts;
+
+      if (flushed)
+        m_header->flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
+    }
+    return true;
+  }
+  return false;
+}
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferMMAL.h	2023-04-09 15:52:35.779849872 +0000
@@ -0,0 +1,93 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "threads/CriticalSection.h"
+
+#include <interface/mmal/mmal.h>
+
+extern "C"
+{
+#include <libavcodec/mmal_zc.h>
+}
+
+#define MMAL_BUFFER_HEADER_FLAG_ZEROCOPY (MMAL_BUFFER_HEADER_FLAG_USER0)
+#define MMAL_BUFFER_HEADER_FLAG_DROPPED (MMAL_BUFFER_HEADER_FLAG_USER1)
+#define MMAL_BUFFER_HEADER_FLAG_SEEK (MMAL_BUFFER_HEADER_FLAG_USER2)
+
+namespace MMAL
+{
+typedef MMAL_STATUS_T MMALStatus;
+typedef MMAL_COMPONENT_T* MMALComponent;
+typedef MMAL_PORT_T* MMALPort;
+typedef MMAL_POOL_T* MMALPool;
+typedef MMAL_QUEUE_T* MMALQueue;
+typedef MMAL_ES_FORMAT_T* MMALFormat;
+typedef MMAL_BUFFER_HEADER_T* MMALBufferHeader;
+
+class CVideoBufferMMAL : public CVideoBuffer
+{
+public:
+  CVideoBufferMMAL() = delete;
+  CVideoBufferMMAL(int id, MMALBufferHeader header);
+  ~CVideoBufferMMAL() override;
+
+  void Acquire() override;
+  void Acquire(bool lockMemory);
+  void Acquire(std::shared_ptr<IVideoBufferPool> pool) override;
+  void Release() override;
+
+  void SetDimensions(int width, int height);
+  void SetDimensions(int width, int height, const int (&strides)[YuvImage::MAX_PLANES]) override;
+  void SetDimensions(int width,
+                     int height,
+                     const int (&strides)[YuvImage::MAX_PLANES],
+                     const int (&planeOffsets)[YuvImage::MAX_PLANES]) override;
+
+  void GetPlanes(uint8_t* (&planes)[YuvImage::MAX_PLANES]) override;
+  void GetStrides(int (&strides)[YuvImage::MAX_PLANES]) override;
+  uint8_t* GetMemPtr() override;
+
+  const VideoPicture& GetPicture() const { return m_picture; }
+  void SetBasePicture(VideoPicture* pBasePicture);
+
+  int GetRenderIndex();
+  void SetRenderIndex(int renderIndex);
+
+  MMALBufferHeader GetHeader() { return m_header; };
+  int GetSize() { return m_header->alloc_size; };
+
+  MMALFormat GetPortFormat();
+  void SetPortFormat(MMALFormat portFormat);
+
+  bool UpdateBufferFromFrame(AVFrame* frame, AVCodecID codecId, bool flushed, AVZcEnvPtr envPtr = nullptr);
+
+  void ReleasePtr();
+  void Dispose();
+
+protected:
+  VideoPicture m_picture;
+
+private:
+  void UpdatePictureParams();
+
+  MMALBufferHeader m_header{nullptr};
+  MMALFormat m_portFormat{nullptr};
+  bool m_locked{false};
+  bool m_disposing{false};
+
+  int m_renderIndex{-1};
+  AVMMALZcRefPtr m_refPtr{nullptr};
+
+  CCriticalSection m_critSection;
+};
+
+} // namespace MMAL
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.cpp	2023-04-09 15:56:00.724502541 +0000
@@ -0,0 +1,587 @@
+/*
+ *  Copyright (C) 2005-2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoBufferPoolMMAL.h"
+
+#include "ServiceBroker.h"
+#include "threads/SingleLock.h"
+#include "threads/Timer.h"
+#include "utils/BufferObjectFactory.h"
+#include "utils/log.h"
+#include "windowing/dmx/WinSystemDmx.h"
+
+#define MMAL_COMPONENT_DEFAULT_NULL_SINK "vc.null_sink"
+
+using namespace MMAL;
+
+uint32_t CVideoBufferPoolMMAL::TranslateFormat(AVPixelFormat format)
+{
+  switch (format)
+  {
+    case AV_PIX_FMT_MMAL:
+      return MMAL_ENCODING_OPAQUE;
+    case AV_PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUVJ420P:
+      return MMAL_ENCODING_I420;
+    case AV_PIX_FMT_YUV420P10:
+      return MMAL_ENCODING_I420_10;
+    case AV_PIX_FMT_YUV420P12:
+    case AV_PIX_FMT_YUV420P14:
+    case AV_PIX_FMT_YUV420P16:
+      return MMAL_ENCODING_I420_16;
+    case AV_PIX_FMT_SAND128:
+      return MMAL_ENCODING_YUVUV128;
+    case AV_PIX_FMT_SAND64_10:
+      return MMAL_ENCODING_YUVUV64_10;
+    case AV_PIX_FMT_SAND64_16:
+      return MMAL_ENCODING_YUVUV64_16;
+    case AV_PIX_FMT_YUV411P:
+    case AV_PIX_FMT_YUVJ411P:
+      return MMAL_ENCODING_YV12;
+    case AV_PIX_FMT_YUV422P:
+    case AV_PIX_FMT_YUVJ422P:
+      return MMAL_ENCODING_I422;
+    case AV_PIX_FMT_NV12:
+      return MMAL_ENCODING_NV12;
+    case AV_PIX_FMT_NV21:
+      return MMAL_ENCODING_NV21;
+    case AV_PIX_FMT_RGBA:
+    case AV_PIX_FMT_RGB0:
+      return MMAL_ENCODING_RGBA;
+    case AV_PIX_FMT_BGRA:
+    case AV_PIX_FMT_BGR0:
+      return MMAL_ENCODING_BGRA;
+    case AV_PIX_FMT_RGB24:
+      return MMAL_ENCODING_RGB24;
+    case AV_PIX_FMT_BGR24:
+      return MMAL_ENCODING_BGR24;
+    case AV_PIX_FMT_RGB565:
+      return MMAL_ENCODING_RGB16;
+    case AV_PIX_FMT_BGR565:
+      return MMAL_ENCODING_BGR16;
+    default:
+      return MMAL_ENCODING_UNKNOWN;
+  }
+}
+
+AVPixelFormat CVideoBufferPoolMMAL::TranslatePortFormat(uint32_t format)
+{
+  switch (format)
+  {
+    case MMAL_ENCODING_OPAQUE:
+      return AV_PIX_FMT_MMAL;
+    case MMAL_ENCODING_I420:
+      return AV_PIX_FMT_YUV420P;
+    case MMAL_ENCODING_I420_10:
+      return AV_PIX_FMT_YUV420P10;
+    case MMAL_ENCODING_I420_16:
+      return AV_PIX_FMT_YUV420P16;
+    case MMAL_ENCODING_YUVUV128:
+      return AV_PIX_FMT_SAND128;
+    case MMAL_ENCODING_YUVUV64_10:
+      return AV_PIX_FMT_SAND64_10;
+    case MMAL_ENCODING_YUVUV64_16:
+      return AV_PIX_FMT_SAND64_16;
+    case MMAL_ENCODING_YV12:
+      return AV_PIX_FMT_YUV411P;
+    case MMAL_ENCODING_I422:
+      return AV_PIX_FMT_YUV422P;
+    case MMAL_ENCODING_NV12:
+      return AV_PIX_FMT_NV12;
+    case MMAL_ENCODING_NV21:
+      return AV_PIX_FMT_NV21;
+    case MMAL_ENCODING_RGBA:
+      return AV_PIX_FMT_RGBA;
+    case MMAL_ENCODING_BGRA:
+      return AV_PIX_FMT_BGRA;
+    case MMAL_ENCODING_RGB32:
+      return AV_PIX_FMT_RGB32;
+    case MMAL_ENCODING_BGR32:
+      return AV_PIX_FMT_BGR32;
+    case MMAL_ENCODING_RGB24:
+      return AV_PIX_FMT_RGB24;
+    case MMAL_ENCODING_BGR24:
+      return AV_PIX_FMT_BGR24;
+    case MMAL_ENCODING_RGB16:
+      return AV_PIX_FMT_RGB565;
+    case MMAL_ENCODING_BGR16:
+      return AV_PIX_FMT_BGR565;
+    default:
+      return AV_PIX_FMT_NONE;
+  }
+}
+
+uint32_t CVideoBufferPoolMMAL::TranslateCodec(AVCodecID codec)
+{
+  switch (codec)
+  {
+    case AV_CODEC_ID_H264:
+      return MMAL_ENCODING_H264;
+    case AV_CODEC_ID_MPEG4:
+      return MMAL_ENCODING_MP4V;
+    case AV_CODEC_ID_MJPEG:
+      return MMAL_ENCODING_MJPEG;
+    case AV_CODEC_ID_H263:
+      return MMAL_ENCODING_H263;
+    case AV_CODEC_ID_MPEG1VIDEO:
+      return MMAL_ENCODING_MP1V;
+    case AV_CODEC_ID_MPEG2VIDEO:
+      return MMAL_ENCODING_MP2V;
+    case AV_CODEC_ID_VP6:
+      return MMAL_ENCODING_VP6;
+    case AV_CODEC_ID_VP7:
+      return MMAL_ENCODING_VP7;
+    case AV_CODEC_ID_VP8:
+      return MMAL_ENCODING_VP8;
+    case AV_CODEC_ID_WMV1:
+      return MMAL_ENCODING_WMV1;
+    case AV_CODEC_ID_WMV2:
+      return MMAL_ENCODING_WMV2;
+    case AV_CODEC_ID_WMV3:
+      return MMAL_ENCODING_WMV3;
+    case AV_CODEC_ID_VC1:
+      return MMAL_ENCODING_WVC1;
+    case AV_CODEC_ID_THEORA:
+      return MMAL_ENCODING_THEORA;
+    default:
+      return MMAL_ENCODING_UNKNOWN;
+  }
+}
+
+uint32_t CVideoBufferPoolMMAL::TranslateColorSpace(AVColorSpace space)
+{
+  switch (space)
+  {
+    case AVCOL_SPC_BT709:
+      return MMAL_COLOR_SPACE_ITUR_BT709;
+    case AVCOL_SPC_SMPTE170M:
+    case AVCOL_SPC_BT470BG:
+      return MMAL_COLOR_SPACE_ITUR_BT601;
+    case AVCOL_SPC_FCC:
+      return MMAL_COLOR_SPACE_FCC;
+    case AVCOL_SPC_SMPTE240M:
+      return MMAL_COLOR_SPACE_SMPTE240M;
+    default:
+      return MMAL_COLOR_SPACE_UNKNOWN;
+  }
+}
+
+int32_t CVideoBufferPoolMMAL::ProcessBufferCallback(MMALPool pool,
+                                                    MMALBufferHeader header,
+                                                    void* userdata)
+{
+  CVideoBufferPoolMMAL* bufferPool = static_cast<CVideoBufferPoolMMAL*>(userdata);
+  if (bufferPool && header->user_data)
+  {
+    CVideoBufferMMAL* buffer = static_cast<CVideoBufferMMAL*>(header->user_data);
+    if (buffer)
+    {
+      bufferPool->Return(buffer->GetId());
+      if (bufferPool->m_callback)
+        bufferPool->m_callback(bufferPool, buffer, bufferPool->m_userdata);
+      return MMAL_FALSE;
+    }
+  }
+  return MMAL_TRUE;
+}
+/*
+CVideoBufferPoolMMAL::CVideoBufferPoolMMAL()
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+}
+*/
+CVideoBufferPoolMMAL::~CVideoBufferPoolMMAL()
+{
+
+  //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - destroying", __FUNCTION__);
+  Dispose();
+  if (m_portFormat)
+  {
+    mmal_format_free(m_portFormat);
+    m_portFormat = nullptr;
+  }
+
+  if (m_component)
+  {
+    //for (auto buf : m_all)
+    //  delete buf;
+    //m_all.clear();
+
+    if (mmal_component_release(m_component) != MMAL_SUCCESS)
+      CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to release component", __FUNCTION__);
+    m_component = nullptr;
+  }
+
+  //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - destroyed", __FUNCTION__);
+}
+
+void CVideoBufferPoolMMAL::Initialize()
+{
+  MMALStatus status = MMAL_SUCCESS;
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_NULL_SINK, &m_component);
+  if (status == MMAL_SUCCESS)
+  {
+    if (m_component->is_enabled != 0)
+      status = mmal_component_disable(m_component);
+    if (m_component->input[0]->is_enabled != 0)
+      status = mmal_port_disable(m_component->input[0]);
+    if (status == MMAL_SUCCESS)
+    {
+      m_port = m_component->input[0];
+      m_port->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+      m_port->buffer_num = 0;
+      m_port->buffer_size = 0;
+      m_port->format->encoding = MMAL_ENCODING_UNKNOWN;
+      m_port->format->encoding_variant = MMAL_ENCODING_UNKNOWN;
+      m_portFormat = mmal_format_alloc();
+      m_portFormat->type = MMAL_ES_TYPE_VIDEO;
+      mmal_port_parameter_set_uint32(m_port, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+      mmal_port_parameter_set_boolean(m_port, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+      if (mmal_port_format_commit(m_port) == MMAL_SUCCESS)
+      {
+        mmal_format_full_copy(m_portFormat, m_port->format);
+        m_portFormat->encoding = MMAL_ENCODING_UNKNOWN;
+        m_portFormat->encoding_variant = MMAL_ENCODING_UNKNOWN;
+        m_portFormat->extradata = nullptr;
+        m_portFormat->extradata_size = 0;
+      }
+      else
+        CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to commit port", __FUNCTION__);
+    }
+    else
+      CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to disable ports", __FUNCTION__);
+  }
+  else
+    CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to create component", __FUNCTION__);
+}
+
+void CVideoBufferPoolMMAL::Dispose()
+{
+  if (m_port)
+  {
+    if (m_pool)
+    {
+      std::unique_lock<CCriticalSection> lock(m_poolLock);
+      //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - setcallback", __FUNCTION__);
+      mmal_pool_callback_set(m_pool, NULL, nullptr);
+
+      for (auto buf : m_all)
+        buf->Dispose();
+
+      if (m_pool->header)
+      {
+        //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - free Header", __FUNCTION__);
+        vcos_free(m_pool->header);
+        m_pool->header = nullptr;
+        //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - freed Header", __FUNCTION__);
+      }
+
+      if (m_pool->queue)
+      {
+        //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - free queue", __FUNCTION__);
+        mmal_queue_destroy(m_pool->queue);
+        m_pool->queue = nullptr;
+        //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - freed  queue", __FUNCTION__);
+      }
+
+      //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - free ", __FUNCTION__);
+      vcos_free(m_pool);
+      //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - freed ", __FUNCTION__);
+      m_pool = nullptr;
+    }
+    m_port->userdata = nullptr;
+    m_port = nullptr;
+  }
+}
+
+CVideoBuffer* CVideoBufferPoolMMAL::Get()
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  if (m_free.empty())
+    return nullptr;
+
+  CVideoBufferMMAL* buffer = nullptr;
+  int id = m_free.front();
+  m_free.pop_front();
+  m_used.push_back(id);
+
+  buffer = m_all[id];
+
+  if (buffer)
+    buffer->Acquire(GetPtr());
+
+  return buffer;
+}
+
+CVideoBuffer* CVideoBufferPoolMMAL::Get(bool rendered)
+{
+  if (rendered)
+  {
+    std::unique_lock<CCriticalSection> lock(m_poolLock);
+    if (m_ready.empty())
+      return nullptr;
+
+    CVideoBufferMMAL* buffer = nullptr;
+    int id = m_ready.front();
+    m_ready.pop_front();
+    m_used.push_back(id);
+
+    buffer = m_all[id];
+
+    if (buffer)
+      buffer->Acquire(GetPtr());
+    return buffer;
+  }
+  else
+    return Get();
+}
+
+bool CVideoBufferPoolMMAL::Move(AVFrame* frame, AVCodecID codecId, bool flushed, void* envPtr)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  if (m_free.empty())
+    return false;
+
+  CVideoBufferMMAL* buffer = nullptr;
+  int id = m_free.front();
+  m_free.pop_front();
+  m_ready.push_back(id);
+
+  buffer = m_all[id];
+
+  if (buffer)
+    return buffer->UpdateBufferFromFrame(frame, codecId, flushed,
+                                         envPtr ? (AVZcEnvPtr)envPtr : nullptr);
+
+  return buffer != nullptr;
+}
+
+void CVideoBufferPoolMMAL::Put(CVideoBufferMMAL* buffer)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  int id = buffer->GetId();
+  auto it = m_free.begin();
+  while (it != m_free.end())
+  {
+    if (*it == id)
+    {
+      m_free.erase(it);
+      break;
+    }
+    else
+      ++it;
+  }
+  m_ready.push_back(id);
+}
+
+void CVideoBufferPoolMMAL::Return(int id)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  auto it = m_used.begin();
+  while (it != m_used.end())
+  {
+    if (*it == id)
+    {
+      m_used.erase(it);
+      break;
+    }
+    else
+      ++it;
+  }
+  m_free.push_back(id);
+  if (m_bufferManager && m_used.empty())
+  {
+    (m_bufferManager->*m_disposeCallback)(this);
+    for (auto buffer : m_all)
+      delete buffer;
+    m_all.clear();
+  }
+}
+
+void CVideoBufferPoolMMAL::Flush()
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  if (m_ready.empty())
+    return;
+
+  while (!m_ready.empty())
+  {
+    int id = m_ready.front();
+    m_ready.pop_front();
+    m_free.push_back(id);
+    if (m_callback)
+      m_callback(this, m_all[id], m_userdata);
+  }
+}
+
+uint32_t CVideoBufferPoolMMAL::Length(bool rendered)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  if (rendered)
+    return m_ready.size();
+  else
+    return m_free.size();
+}
+
+void CVideoBufferPoolMMAL::Configure(AVPixelFormat format, int size)
+{
+  m_portFormat->encoding = TranslateFormat(format);
+  m_portFormat->encoding_variant = 0;
+  Configure(m_portFormat, nullptr, 0, size);
+}
+
+void CVideoBufferPoolMMAL::Configure(MMALFormat portFormat,
+                                     VideoPicture* pBasePicture,
+                                     uint32_t count,
+                                     int32_t size)
+{
+  if (m_component == nullptr)
+  {
+    MMALStatus status = MMAL_SUCCESS;
+    status = mmal_component_create(MMAL_COMPONENT_DEFAULT_NULL_SINK, &m_component);
+    if (status == MMAL_SUCCESS)
+    {
+      if (m_component->is_enabled != 0)
+        status = mmal_component_disable(m_component);
+      if (m_component->input[0]->is_enabled != 0)
+        status = mmal_port_disable(m_component->input[0]);
+      if (status == MMAL_SUCCESS)
+      {
+        m_port = m_component->input[0];
+        m_port->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+        m_port->buffer_num = 0;
+        m_port->buffer_size = size;
+        m_port->format->encoding = portFormat->encoding;
+        m_port->format->encoding_variant = portFormat->encoding_variant;
+        m_portFormat = mmal_format_alloc();
+        m_portFormat->type = MMAL_ES_TYPE_VIDEO;
+        mmal_port_parameter_set_uint32(m_port, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+        mmal_port_parameter_set_boolean(m_port, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+        if (mmal_port_format_commit(m_port) == MMAL_SUCCESS)
+        {
+          mmal_format_full_copy(m_portFormat, m_port->format);
+          m_portFormat->encoding = MMAL_ENCODING_UNKNOWN;
+          m_portFormat->encoding_variant = MMAL_ENCODING_UNKNOWN;
+          m_portFormat->extradata = nullptr;
+          m_portFormat->extradata_size = 0;
+        }
+        else
+          CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to commit port", __FUNCTION__);
+      }
+      else
+        CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to disable ports", __FUNCTION__);
+    }
+    else
+      CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to create component", __FUNCTION__);
+  }
+  if (mmal_format_compare(m_portFormat, portFormat) != 0)
+  {
+    if (mmal_format_full_copy(m_portFormat, portFormat) != MMAL_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to copy port format", __FUNCTION__);
+      return;
+    }
+  }
+
+  if (count > 0)
+  {
+    if (!m_pool)
+    {
+      if ((m_pool = mmal_port_pool_create(m_port, count, size)) == NULL)
+      {
+        CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to create pool", __FUNCTION__);
+        return;
+      }
+      m_size = size;
+      mmal_pool_callback_set(m_pool, CVideoBufferPoolMMAL::ProcessBufferCallback, (void*)this);
+    }
+    else if (m_size != size)
+    {
+      if (mmal_pool_resize(m_pool, count, size) != MMAL_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "CVideoBufferPoolMMAL::{} - failed to resize pool", __FUNCTION__);
+        return;
+      }
+      m_size = size;
+    }
+    InitializeBuffers(pBasePicture);
+    if (m_port->is_enabled == 0)
+      mmal_port_enable(m_port, NULL);
+    if (m_component->is_enabled == 0)
+      mmal_component_enable(m_component);
+  }
+}
+
+void CVideoBufferPoolMMAL::InitializeBuffers(VideoPicture* pBasePicture)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  MMALBufferHeader header = nullptr;
+  while ((header = mmal_queue_get(m_pool->queue)) != NULL)
+  {
+    int index = m_all.size();
+    CVideoBufferMMAL* buffer = new CVideoBufferMMAL(index, header);
+    m_all.push_back(buffer);
+    m_free.push_back(index);
+
+    if (pBasePicture)
+      buffer->SetBasePicture(pBasePicture);
+
+    if (m_callback)
+      m_callback(this, buffer, m_userdata);
+  }
+  lock.unlock();
+
+  for (auto buffer : m_all)
+    buffer->SetPortFormat(m_portFormat);
+}
+
+void CVideoBufferPoolMMAL::SetReleaseCallback(IVideoBufferPoolMMALCallback callback, void* userdata)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  m_callback = callback;
+  m_userdata = userdata;
+}
+
+bool CVideoBufferPoolMMAL::IsConfigured()
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  return m_component != nullptr && m_size != -1 && m_pool != nullptr &&
+         m_portFormat->encoding != MMAL_ENCODING_UNKNOWN;
+}
+
+bool CVideoBufferPoolMMAL::IsCompatible(AVPixelFormat format, int size)
+{
+  std::unique_lock<CCriticalSection> lock(m_poolLock);
+  if (m_component != nullptr && m_portFormat->encoding != TranslateFormat(format) && size != m_size)
+    return false;
+
+  return true;
+}
+
+void CVideoBufferPoolMMAL::Released(CVideoBufferManager& videoBufferManager)
+{
+  //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - released pool", __FUNCTION__);
+  videoBufferManager.RegisterPool(std::make_shared<CVideoBufferPoolMMAL>());
+}
+
+void CVideoBufferPoolMMAL::Discard(CVideoBufferManager* bm, ReadyToDispose cb)
+{
+  //CLog::Log(LOGDEBUG, "CVideoBufferPoolMMAL::{} - discarding pool", __FUNCTION__);
+  if (m_used.empty())
+  {
+    (bm->*cb)(this);
+    for (auto buffer : m_all)
+      delete buffer;
+    m_all.clear();
+  }
+  else
+  {
+    m_bufferManager = bm;
+    m_disposeCallback = cb;
+  }
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h	2023-04-09 15:54:42.449871337 +0000
@@ -0,0 +1,99 @@
+/*
+ *  Copyright (C) 2005-2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+#include "cores/VideoPlayer/Buffers/VideoBufferMMAL.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Condition.h"
+
+#include <memory>
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_events.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/vc/mmal_vc_msgs.h>
+
+extern "C"
+{
+#include <libavcodec/codec_id.h>
+#include <libavutil/pixfmt.h>
+}
+namespace MMAL
+{
+class CVideoBufferMMAL;
+class CVideoBufferPoolMMAL;
+
+typedef void (*IVideoBufferPoolMMALCallback)(CVideoBufferPoolMMAL* pool,
+                                             CVideoBufferMMAL* buffer,
+                                             void* userdata);
+
+class CVideoBufferPoolMMAL : public IVideoBufferPool
+{
+public:
+  static uint32_t TranslateCodec(AVCodecID codec);
+  static uint32_t TranslateFormat(AVPixelFormat format);
+  static uint32_t TranslateColorSpace(AVColorSpace space);
+  static AVPixelFormat TranslatePortFormat(uint32_t format);
+
+  CVideoBufferPoolMMAL() = default;
+  ~CVideoBufferPoolMMAL() override;
+
+  CVideoBuffer* Get() override;
+  CVideoBuffer* Get(bool rendered);
+  void Return(int id) override;
+
+  void Put(CVideoBufferMMAL* buffer);
+  bool Move(AVFrame* frame, AVCodecID codecId, bool flushed, void* envPtr = nullptr);
+  void Flush();
+  uint32_t Length(bool rendered = false);
+
+  void Configure(AVPixelFormat format, int size) override;
+  void Configure(MMALFormat portFormat, VideoPicture* pBasePicture, uint32_t count, int32_t size);
+
+  bool IsConfigured() override;
+  bool IsCompatible(AVPixelFormat format, int size) override;
+
+  void Released(CVideoBufferManager& videoBufferManager) override;
+  void SetReleaseCallback(IVideoBufferPoolMMALCallback callback = nullptr,
+                          void* userdata = nullptr);
+  void Discard(CVideoBufferManager* bm, ReadyToDispose cb) override;
+  void Dispose();
+
+protected:
+  void Initialize();
+  void InitializeBuffers(VideoPicture* pBasePicture);
+
+  std::vector<CVideoBufferMMAL*> m_all;
+  std::deque<int> m_used;
+  std::deque<int> m_free;
+  std::deque<int> m_ready;
+
+  CVideoBufferManager* m_bufferManager = nullptr;
+  ReadyToDispose m_disposeCallback{NULL};
+
+  CCriticalSection m_poolLock;
+
+private:
+  static int32_t ProcessBufferCallback(MMALPool pool, MMALBufferHeader header, void* userdata);
+
+  MMALComponent m_component{nullptr};
+  MMALFormat m_portFormat{nullptr};
+  MMALPort m_port{nullptr};
+  MMALPool m_pool{nullptr};
+
+  int m_size{-1};
+
+  IVideoBufferPoolMMALCallback m_callback{NULL};
+  void* m_userdata{nullptr};
+};
+
+} // namespace MMAL
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt	2023-04-06 12:36:50.000000000 +0000
@@ -26,6 +26,14 @@
   list(APPEND HEADERS VAAPI.h)
 endif()
 
+
+if(MMAL_FOUND)
+  list(APPEND SOURCES DVDVideoCodecMMAL.cpp
+                      DVDVideoCodecFFmpegMMAL.cpp)
+  list(APPEND HEADERS DVDVideoCodecMMAL.h
+                      DVDVideoCodecFFmpegMMAL.h)
+endif()
+
 if(APPLE)
   list(APPEND SOURCES VTB.cpp)
   list(APPEND HEADERS VTB.h)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.cpp	2023-04-10 16:58:40.307248984 +0000
@@ -0,0 +1,771 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DVDVideoCodecFFmpegMMAL.h"
+
+#include "ServiceBroker.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDCodecs.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "threads/SingleLock.h"
+#include "utils/CPUInfo.h"
+#include "utils/XTimeUtils.h"
+#include "utils/log.h"
+
+#include <float.h>
+#include <signal.h>
+#include <thread>
+
+#include <pthread.h>
+#include <sys/resource.h>
+#include <sys/syscall.h>
+
+extern "C"
+{
+#include <libavcodec/avcodec.h>
+#include <libavutil/dict.h>
+#include <libavutil/error.h>
+#include <libavutil/imgutils.h>
+#include <libavutil/opt.h>
+#include <libavutil/pixdesc.h>
+}
+using namespace MMAL;
+using namespace std::chrono_literals;
+
+enum AVStatus : int
+{
+  AV_SUCCESS = 0, /**< Success */
+  AV_ENOMEM = AVERROR(ENOMEM), /**< Out of memory */
+  AV_ENOSPC = AVERROR(ENOSPC), /**< Out of resources (other than memory) */
+  AV_EINVAL = AVERROR(EINVAL), /**< Argument is invalid */
+  AV_ENOSYS = AVERROR(ENOSYS), /**< Function not implemented */
+  AV_ENOENT = AVERROR(ENOENT), /**< No such file or directory */
+  AV_ENXIO = AVERROR(ENXIO), /**< No such device or address */
+  AV_EIO = AVERROR(EIO), /**< I/O error */
+  AV_ESPIPE = AVERROR(ESPIPE), /**< Illegal seek */
+  AV_ECORRUPT = AVERROR_INVALIDDATA, /**< Invalid data */
+  AV_EOS = AVERROR_EOF, /**< End of stream */
+  AV_EAGAIN = AVERROR(EAGAIN), /**< Resource temporarily unavailable. Try again later*/
+  AV_EFAULT = AVERROR(ENOENT), /**< Bad address */
+  AV_STATUS_MAX = 0x7FFFFFFF /**< Force to 32 bit */
+};
+
+constexpr const char* SETTING_VIDEOPLAYER_USEMMALDECODERFORHW{"videoplayer.usemmaldecoderforhw"};
+
+std::unique_ptr<CDVDVideoCodec> CDVDVideoCodecFFmpegMMAL::CreateCodec(CProcessInfo& processInfo)
+{
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+          CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER))
+    return std::make_unique<CDVDVideoCodecFFmpegMMAL>(processInfo);
+  return nullptr;
+}
+
+void CDVDVideoCodecFFmpegMMAL::Register()
+{
+  auto settingsComponent = CServiceBroker::GetSettingsComponent();
+  if (!settingsComponent)
+    return;
+
+  auto settings = settingsComponent->GetSettings();
+  if (!settings)
+    return;
+
+  auto setting = settings->GetSetting(CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER);
+  if (!setting)
+  {
+    CLog::Log(LOGERROR, "Failed to load setting for: {}",
+              CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER);
+    return;
+  }
+  setting->SetVisible(true);
+
+  setting = settings->GetSetting(SETTING_VIDEOPLAYER_USEMMALDECODERFORHW);
+  if (!setting)
+  {
+    CLog::Log(LOGERROR, "Failed to load setting for: {}", SETTING_VIDEOPLAYER_USEMMALDECODERFORHW);
+    return;
+  }
+  setting->SetVisible(true);
+
+  CDVDFactoryCodec::RegisterHWVideoCodec("mmal-hevc", CDVDVideoCodecFFmpegMMAL::CreateCodec);
+}
+
+enum AVPixelFormat CDVDVideoCodecFFmpegMMAL::GetFormatCallback(struct AVCodecContext* avctx,
+                                                               const enum AVPixelFormat* fmt)
+{
+  CDVDVideoCodecFFmpegMMAL* codec = static_cast<CDVDVideoCodecFFmpegMMAL*>(avctx->opaque);
+  if (codec)
+  {
+    for (int n = 0; fmt[n] != AV_PIX_FMT_NONE; n++)
+    {
+      if (fmt[n] == AV_PIX_FMT_SAND128 || fmt[n] == AV_PIX_FMT_SAND64_10 ||
+          fmt[n] == AV_PIX_FMT_YUV420P || fmt[n] == AV_PIX_FMT_YUV420P10 ||
+          fmt[n] == AV_PIX_FMT_YUV422P || fmt[n] == AV_PIX_FMT_YUV422P10)
+      {
+        if (avctx->colorspace != AVCOL_SPC_UNSPECIFIED)
+          codec->m_hints.colorSpace = avctx->colorspace;
+
+        codec->m_portFormat->encoding = CVideoBufferPoolMMAL::TranslateFormat(fmt[n]);
+        codec->m_portFormat->encoding_variant = 0;
+        codec->m_portFormat->es->video.width = avctx->width;
+        codec->m_portFormat->es->video.height = avctx->height;
+        codec->m_portFormat->es->video.color_space =
+            CVideoBufferPoolMMAL::TranslateColorSpace(codec->m_hints.colorSpace);
+
+        if (fmt[n] == AV_PIX_FMT_SAND128 || fmt[n] == AV_PIX_FMT_SAND64_10)
+        {
+          AVMMALZcFrameGeometry geometry =
+              av_mmal_zc_frame_geometry(fmt[n], avctx->width, avctx->height);
+          if (geometry.stripe_is_yc)
+            codec->m_portFormat->es->video.width = geometry.height_y + geometry.height_c;
+          else
+            codec->m_portFormat->es->video.width = geometry.height_y;
+          codec->m_portFormat->es->video.height = geometry.height_y;
+
+          codec->m_portFormat->es->video.crop.width = avctx->width;
+          codec->m_portFormat->es->video.crop.height = avctx->height;
+          codec->m_portFormat->flags |= MMAL_ES_FORMAT_FLAG_COL_FMTS_WIDTH_IS_COL_STRIDE;
+        }
+        else
+        {
+          codec->m_portFormat->es->video.width = VCOS_ALIGN_UP(avctx->width, 32);
+          codec->m_portFormat->es->video.height = VCOS_ALIGN_UP(avctx->height, 16);
+
+          if ((uint32_t)avctx->width < codec->m_portFormat->es->video.width)
+            codec->m_portFormat->es->video.crop.width = avctx->width;
+
+          if ((uint32_t)avctx->height < codec->m_portFormat->es->video.height)
+            codec->m_portFormat->es->video.crop.height = avctx->height;
+        }
+        if (avctx->framerate.num != 0 && avctx->framerate.den != 1)
+        {
+          codec->m_portFormat->es->video.frame_rate.num = avctx->framerate.num;
+          codec->m_portFormat->es->video.frame_rate.den = avctx->framerate.den;
+        }
+
+        if (codec->m_hints.forced_aspect)
+        {
+          codec->m_portFormat->es->video.par.num = avctx->sample_aspect_ratio.num;
+          codec->m_portFormat->es->video.par.den = avctx->sample_aspect_ratio.den;
+        }
+        codec->UpdateProcessInfo();
+        return fmt[n];
+      }
+    }
+  }
+
+  CLog::Log(LOGERROR, "CDVDVideoCodecFFmpegMMAL::{} - unsupported pixel format", __FUNCTION__);
+  return AV_PIX_FMT_NONE;
+}
+
+CDVDVideoCodecFFmpegMMAL::CDVDVideoCodecFFmpegMMAL(CProcessInfo& processInfo)
+  : CDVDVideoCodec(processInfo), CThread("FFmpegMMAL")
+{
+  m_name = "ff-mmal";
+
+  m_bufferPool = std::make_shared<CVideoBufferPoolMMAL>();
+  m_portFormat = mmal_format_alloc();
+  m_portFormat->extradata = nullptr;
+  m_portFormat->extradata_size = 0;
+
+  m_state = MCS_INITIALIZED;
+}
+
+CDVDVideoCodecFFmpegMMAL::~CDVDVideoCodecFFmpegMMAL()
+{
+  if (m_state == MCS_DECODING)
+  {
+    Flush();
+    KODI::TIME::Sleep(250ms);
+  }
+  m_state = MCS_CLOSED;
+  m_bStop = true;
+  if (!IsRunning() || !Join(500ms))
+  {
+    if (m_context)
+    {
+      avcodec_free_context(&m_context);
+      m_context = nullptr;
+    }
+  }
+
+  if (m_bufferPool)
+  {
+    m_bufferPool->Dispose();
+    m_bufferPool = nullptr;
+  }
+
+  if (m_portFormat)
+  {
+    mmal_format_free(m_portFormat);
+    m_portFormat = nullptr;
+  }
+  m_state = MCS_UNINITIALIZED;
+}
+
+void CDVDVideoCodecFFmpegMMAL::UpdateProcessInfo()
+{
+  m_format = CVideoBufferPoolMMAL::TranslatePortFormat(m_portFormat->encoding);
+  const char* pixFmtName = av_get_pix_fmt_name(m_format);
+
+  m_fps = 0.0f;
+  m_aspect = 0.0f;
+
+  if (m_portFormat->es->video.frame_rate.num > 0 && m_portFormat->es->video.frame_rate.den > 0)
+    m_fps = (float)m_portFormat->es->video.frame_rate.num /
+            (float)m_portFormat->es->video.frame_rate.den;
+
+  if (m_portFormat->es->video.par.num > 0 && m_portFormat->es->video.par.den > 0)
+    m_aspect = (float)m_portFormat->es->video.par.num / (float)m_portFormat->es->video.par.den;
+
+  if (m_portFormat->es->video.crop.width > 0 && m_portFormat->es->video.crop.height > 0)
+  {
+    m_width = m_portFormat->es->video.crop.width;
+    m_height = m_portFormat->es->video.crop.height;
+  }
+  else
+  {
+    m_width = m_portFormat->es->video.width;
+    m_height = m_portFormat->es->video.height;
+  }
+
+  if (m_aspect > 0.0f)
+  {
+    m_displayWidth = (static_cast<uint32_t>(lrint(m_height * m_aspect))) & -3;
+    m_displayHeight = m_height;
+    if (m_displayWidth > m_width)
+    {
+      m_displayWidth = m_width;
+      m_displayHeight = (static_cast<uint32_t>(lrint(m_width / m_aspect))) & -3;
+    }
+  }
+  else
+  {
+    m_displayWidth = m_width;
+    m_displayHeight = m_height;
+  }
+
+  VideoPicture picture{};
+
+  picture.Reset();
+
+  picture.hasDisplayMetadata = false;
+  picture.hasLightMetadata = false;
+
+  picture.pixelFormat = m_format;
+
+  picture.iWidth = m_width;
+  picture.iHeight = m_height;
+  picture.iDisplayWidth = m_displayWidth;
+  picture.iDisplayHeight = m_displayHeight;
+
+  picture.color_range = m_hints.colorRange == AVCOL_RANGE_JPEG;
+  picture.color_primaries = m_hints.colorPrimaries;
+  picture.color_transfer = m_hints.colorTransferCharacteristic;
+  picture.color_space = m_hints.colorSpace;
+  picture.colorBits = m_hints.bitsperpixel;
+
+  if (m_hints.masteringMetadata)
+  {
+    picture.displayMetadata = *m_hints.masteringMetadata.get();
+    picture.hasDisplayMetadata = true;
+  }
+
+  if (m_hints.contentLightMetadata)
+  {
+    picture.lightMetadata = *m_hints.contentLightMetadata.get();
+    picture.hasLightMetadata = true;
+  }
+  int size = 0;
+  if (m_codec->id != AV_CODEC_ID_HEVC)
+    size = av_image_get_buffer_size(m_format, VCOS_ALIGN_UP(m_width, 32),
+                                    VCOS_ALIGN_UP(m_height, 16), 1);
+
+  m_bufferPool->Configure(m_portFormat, &picture, MMAL_FFMPEG_CODEC_NUM_BUFFERS + 1, size);
+  m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
+  m_processInfo.SetVideoDimensions(m_width, m_height);
+  m_processInfo.SetVideoDecoderName(m_name, true);
+  m_processInfo.SetVideoDeintMethod("none");
+  m_processInfo.SetVideoStereoMode("mono");
+  m_processInfo.SetVideoDAR(m_aspect);
+  m_processInfo.SetVideoFps(m_fps);
+
+  m_state = MCS_DECODING;
+  m_ptsCurrent = AV_NOPTS_VALUE;
+  m_receive = true;
+  if (!IsRunning())
+  {
+    Create(false);
+  }
+}
+
+bool CDVDVideoCodecFFmpegMMAL::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
+{
+  if (m_state != MCS_INITIALIZED)
+    return false;
+
+  if (hints.codec == AV_CODEC_ID_HEVC)
+    m_codec = avcodec_find_decoder_by_name("hevc_mmal");
+  else if (hints.codec == AV_CODEC_ID_AV1)
+    m_codec = avcodec_find_decoder_by_name("libdav1d");
+  else if (hints.codec == AV_CODEC_ID_VP9)
+    m_codec = avcodec_find_decoder_by_name("vp9");
+  else
+  {
+    m_codec = avcodec_find_decoder(hints.codec);
+    if (!m_codec)
+    {
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecFFmpegMMAL::{} - unsupported codec", __FUNCTION__);
+      return false;
+    }
+  }
+
+  if (!m_codec)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpegMMAL::{} - failed to create codec", __FUNCTION__);
+    return false;
+  }
+
+  if ((m_context = avcodec_alloc_context3(m_codec)) == NULL)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpegMMAL::{} - failed to create context", __FUNCTION__);
+    return false;
+  }
+  AVDictionary* codecOptions = NULL;
+  m_context->opaque = static_cast<void*>(this);
+  m_context->get_format = CDVDVideoCodecFFmpegMMAL::GetFormatCallback;
+  m_context->debug_mv = 0;
+  m_context->debug = 0;
+  m_context->workaround_bugs = FF_BUG_AUTODETECT;
+  m_context->thread_safe_callbacks = 1;
+  if (m_codec->id == AV_CODEC_ID_HEVC)
+  {
+    m_context->thread_count = CServiceBroker::GetCPUInfo()->GetCPUCount() * 2;
+    m_context->thread_type = FF_THREAD_FRAME;
+  }
+  else if (m_codec->id == AV_CODEC_ID_AV1)
+  {
+    m_context->thread_count = CServiceBroker::GetCPUInfo()->GetCPUCount();
+    av_dict_set_int(&codecOptions, "framethreads", m_context->thread_count * 2, 0);
+    av_dict_set_int(&codecOptions, "tilethreads", m_context->thread_count, 0);
+  }
+  else if (m_codec->id == AV_CODEC_ID_VP9)
+  {
+    m_context->thread_count = CServiceBroker::GetCPUInfo()->GetCPUCount() * 3 / 2;
+    m_context->thread_type = FF_THREAD_FRAME;
+  }
+  else if ((m_codec->capabilities & AV_CODEC_CAP_AUTO_THREADS) == 0)
+  {
+    m_context->thread_count = CServiceBroker::GetCPUInfo()->GetCPUCount() * 3 / 2;
+  }
+
+  m_context->codec_tag = hints.codec_tag;
+  m_context->coded_width = hints.width;
+  m_context->coded_height = hints.height;
+  m_context->time_base.num = 1;
+  m_context->time_base.den = DVD_TIME_BASE;
+  m_context->bits_per_coded_sample = hints.bitsperpixel;
+  m_context->extra_hw_frames = 0;
+  m_context->pkt_timebase.num = hints.fpsrate;
+  m_context->pkt_timebase.den = hints.fpsscale;
+  m_context->error_concealment = 0;
+  m_context->err_recognition = AV_EF_IGNORE_ERR | AV_EF_EXPLODE;
+
+  if (hints.extradata && hints.extrasize > 0)
+  {
+    m_context->extradata_size = hints.extrasize;
+    m_context->extradata =
+        static_cast<uint8_t*>(av_mallocz(hints.extrasize + AV_INPUT_BUFFER_PADDING_SIZE));
+    memcpy(m_context->extradata, hints.extradata, hints.extrasize);
+  }
+
+  for (auto&& option : options.m_keys)
+    av_opt_set(m_context, option.m_name.c_str(), option.m_value.c_str(), 0);
+
+  m_portFormat->type = MMAL_ES_TYPE_VIDEO;
+  m_portFormat->bitrate = 0;
+  m_portFormat->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
+  m_portFormat->encoding = MMAL_ENCODING_UNKNOWN;
+  m_portFormat->encoding_variant = MMAL_ENCODING_UNKNOWN;
+  m_portFormat->es->video.par.num = 0;
+  m_portFormat->es->video.par.den = 0;
+  m_portFormat->es->video.frame_rate.num = hints.fpsrate;
+  m_portFormat->es->video.frame_rate.den = hints.fpsscale;
+  m_portFormat->es->video.width = VCOS_ALIGN_UP(m_context->coded_width, 32);
+  m_portFormat->es->video.height = VCOS_ALIGN_UP(m_context->coded_height, 16);
+
+  if ((uint32_t)hints.width < m_portFormat->es->video.width)
+    m_portFormat->es->video.crop.width = hints.width;
+
+  if ((uint32_t)hints.height < m_portFormat->es->video.height)
+    m_portFormat->es->video.crop.height = hints.height;
+
+  if (hints.forced_aspect)
+  {
+    m_portFormat->es->video.par.num = 1;
+    m_portFormat->es->video.par.den = 1;
+    if (hints.aspect > 0)
+    {
+      double delta = DBL_MAX;
+      int w = 1, h = 1;
+      for (int i = 0; i < 127; i++)
+      {
+        double d = (double)w / (double)h - hints.aspect;
+        if (d < 0)
+          d = abs(((double)++w / (double)h) - hints.aspect);
+        else
+          d = abs(((double)w / (double)++h) - hints.aspect);
+        if (d < delta)
+        {
+          delta = d;
+          m_portFormat->es->video.par.num = w;
+          m_portFormat->es->video.par.den = h;
+        }
+      }
+    }
+  }
+
+  m_hints = hints;
+  m_state = MCS_OPENED;
+  int status = avcodec_open2(m_context, m_codec, &codecOptions);
+  if (status < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpegMMAL::{} - failed to open codec: {} ({})",
+              __FUNCTION__, GetStatusString(status), status);
+    return false;
+  }
+  m_receive = true;
+  return true;
+}
+
+const char* CDVDVideoCodecFFmpegMMAL::GetStatusString(int status)
+{
+  char msg[AV_ERROR_MAX_STRING_SIZE] = {};
+  av_strerror(status, msg, AV_ERROR_MAX_STRING_SIZE);
+  return msg;
+}
+
+bool CDVDVideoCodecFFmpegMMAL::AddData(const DemuxPacket& packet)
+{
+  MMALCodecState state = m_state;
+  if (packet.pData == nullptr || packet.iSize <= 0)
+  {
+    m_state = MCS_CLOSING;
+    return true;
+  }
+  else if (state == MCS_CLOSED || state == MCS_CLOSING)
+  {
+    return true;
+  }
+  else if (m_receive == false || state == MCS_FLUSHING || state == MCS_ERROR)
+  {
+    return false;
+  }
+  else
+  {
+    bool result = false;
+    if (state == MCS_DECODING || state == MCS_FLUSHED || state == MCS_OPENED)
+    {
+      AVStatus status = AV_SUCCESS;
+      int64_t ptsPacket = AV_NOPTS_VALUE;
+      int64_t dtsPacket = AV_NOPTS_VALUE;
+
+      if (packet.dts != DVD_NOPTS_VALUE)
+        dtsPacket = static_cast<int64_t>(packet.dts / DVD_TIME_BASE * AV_TIME_BASE);
+
+      if (!m_hints.ptsinvalid && packet.pts != DVD_NOPTS_VALUE)
+        ptsPacket = static_cast<int64_t>(packet.pts / DVD_TIME_BASE * AV_TIME_BASE);
+
+      AVPacket avpkt{};
+      avpkt.pos = -1;
+      avpkt.duration = static_cast<int64_t>(packet.duration / DVD_TIME_BASE * AV_TIME_BASE);
+      avpkt.flags = 0;
+      avpkt.stream_index = packet.iStreamId;
+      avpkt.buf = NULL;
+      avpkt.data = packet.pData;
+      avpkt.size = packet.iSize;
+      avpkt.dts = dtsPacket;
+      avpkt.pts = ptsPacket;
+      avpkt.side_data = static_cast<AVPacketSideData*>(packet.pSideData);
+      avpkt.side_data_elems = packet.iSideDataElems;
+
+      if ((m_codecControlFlags & DVD_CODEC_CTRL_DROP) != 0)
+      {
+        avpkt.flags |= AV_PKT_FLAG_DISCARD;
+        m_droppedFrames++;
+      }
+
+      std::unique_lock<CCriticalSection> lock(m_bufferLock);
+      status = static_cast<AVStatus>(avcodec_send_packet(m_context, &avpkt));
+      lock.unlock();
+
+      if (status == AV_SUCCESS)
+      {
+        result = true;
+      }
+      else if (status == AV_EAGAIN)
+      {
+        m_receive = false;
+        result = false;
+      }
+      else if (status == AV_ECORRUPT)
+      {
+        result = true;
+      }
+      else if (status == AV_EOS)
+      {
+        m_state = MCS_CLOSING;
+        m_receive = false;
+        result = true;
+      }
+      else
+      {
+        CLog::Log(LOGERROR, "CDVDVideoCodecFFmpegMMAL::{} - failed to send buffer: {} ({})",
+                  __FUNCTION__, GetStatusString(status), status);
+      }
+    }
+    return result;
+  }
+  return false;
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecFFmpegMMAL::GetPicture(VideoPicture* pVideoPicture)
+{
+  CDVDVideoCodec::VCReturn result = VC_NONE;
+  MMALCodecState state = m_state;
+
+  if (state == MCS_INITIALIZED || state == MCS_UNINITIALIZED)
+  {
+    result = VC_ERROR;
+  }
+  else if (state == MCS_CLOSED || state == MCS_ERROR)
+  {
+    result = VC_EOF;
+  }
+  else if (state == MCS_OPENED)
+  {
+    result = VC_BUFFER;
+  }
+  else if (state == MCS_RESET)
+  {
+    result = VC_FLUSHED;
+  }
+  else
+  {
+    CVideoBufferMMAL* buffer = nullptr;
+    uint32_t available = m_bufferPool->Length(true);
+
+    bool drain = state == MCS_CLOSING || state == MCS_FLUSHING || state == MCS_FLUSHED ||
+                 (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0;
+
+    if (available > 0 && (drain || available >= GetAllowedReferences()) &&
+        (buffer = dynamic_cast<CVideoBufferMMAL*>(m_bufferPool->Get(true))) != NULL)
+    {
+      bool drop = (m_codecControlFlags & DVD_CODEC_CTRL_DROP) != 0;
+
+      pVideoPicture->Reset();
+      pVideoPicture->SetParams(buffer->GetPicture());
+
+      pVideoPicture->iFlags |= m_codecControlFlags;
+
+      if (drop)
+      {
+        if (m_codec->id == AV_CODEC_ID_HEVC)
+          buffer->ReleasePtr();
+        pVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+      }
+
+      pVideoPicture->videoBuffer = buffer;
+
+      result = VC_PICTURE;
+    }
+    else if (state != MCS_CLOSING && m_receive)
+    {
+      if ((m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0)
+        m_codecControlFlags &= ~DVD_CODEC_CTRL_DRAIN;
+
+      result = VC_BUFFER;
+    }
+  }
+
+  return result;
+}
+
+void CDVDVideoCodecFFmpegMMAL::Reset()
+{
+  if (m_state == MCS_DECODING)
+  {
+    Flush();
+    m_receive = false;
+    if ((m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0)
+      m_codecControlFlags &= ~DVD_CODEC_CTRL_DRAIN;
+  }
+}
+
+void CDVDVideoCodecFFmpegMMAL::Flush()
+{
+  AVPacket avpkt;
+  av_init_packet(&avpkt);
+  avpkt.data = nullptr;
+  avpkt.size = 0;
+  avpkt.dts = AV_NOPTS_VALUE;
+  avpkt.pts = AV_NOPTS_VALUE;
+  m_state = MCS_FLUSHING;
+  std::unique_lock<CCriticalSection> lock(m_bufferLock);
+  avcodec_send_packet(m_context, &avpkt);
+}
+
+void CDVDVideoCodecFFmpegMMAL::Process()
+{
+  MMALCodecState state = m_state;
+  AVStatus status = AV_SUCCESS;
+  uint32_t available = 0;
+  AVFrame* frame = av_frame_alloc();
+  CVideoBufferMMAL* buffer = nullptr;
+  pthread_t tid = pthread_self();
+  if (tid)
+  {
+    int policy;
+    struct sched_param param;
+    pthread_getschedparam(tid, &policy, &param);
+    if (policy != SCHED_FIFO)
+    {
+      param.sched_priority = sched_get_priority_max(SCHED_FIFO) - 1;
+      pthread_setschedparam(tid, SCHED_FIFO, &param);
+    }
+  }
+
+  //CLog::Log(LOGDEBUG, "CDVDVideoCodecFFmpegMMAL::{} - decoder thread started", __FUNCTION__);
+  while (!m_bStop && (state == MCS_DECODING || state == MCS_FLUSHING || state == MCS_CLOSING ||
+                      state == MCS_FLUSHED))
+  {
+    available = m_bufferPool->Length();
+    while (status == AV_SUCCESS && (available > 0 || state == MCS_FLUSHING))
+    {
+      std::unique_lock<CCriticalSection> lock(m_bufferLock);
+      status = static_cast<AVStatus>(avcodec_receive_frame(m_context, frame));
+      lock.unlock();
+      if (status == AV_SUCCESS)
+      {
+        if (((frame->flags & AV_FRAME_FLAG_CORRUPT) == 0 &&
+             (frame->flags & AV_FRAME_FLAG_DISCARD) == 0) &&
+            (state == MCS_DECODING || state == MCS_FLUSHED))
+        {
+          if (m_bufferPool->Move(frame, m_codec->id, m_ptsCurrent == AV_NOPTS_VALUE,
+                                 m_context->opaque))
+          {
+            if (state == MCS_FLUSHED)
+              m_state = state = MCS_DECODING;
+            m_ptsCurrent = frame->best_effort_timestamp;
+            available--;
+          }
+          else
+            m_droppedFrames++;
+        }
+        else
+          m_droppedFrames++;
+
+        av_frame_unref(frame);
+      }
+      else
+      {
+        if (status == AV_EOS && state == MCS_FLUSHING)
+        {
+          std::unique_lock<CCriticalSection> lock(m_bufferLock);
+          avcodec_flush_buffers(m_context);
+          lock.unlock();
+          m_bufferPool->Flush();
+          m_ptsCurrent = AV_NOPTS_VALUE;
+          m_droppedFrames = -1;
+          m_state = MCS_FLUSHED;
+          m_receive = true;
+        }
+        break;
+      }
+    }
+    if (status == AV_EAGAIN)
+    {
+      if (available > 0)
+        m_receive = true;
+      else
+        m_receive = false;
+    }
+    else if (status == AV_EOS)
+    {
+      if ((state != MCS_FLUSHING && state != MCS_FLUSHED))
+      {
+        m_state = MCS_CLOSED;
+        m_receive = false;
+      }
+      else if (available > 0)
+        m_receive = true;
+      else
+        m_receive = false;
+    }
+    else
+    {
+      //error
+    }
+    status = AV_SUCCESS;
+    if (!m_receive)
+      KODI::TIME::Sleep(5ms);
+    state = m_state;
+  }
+  av_frame_free(&frame);
+  m_bufferPool->Flush();
+
+  if (m_context)
+  {
+    avcodec_free_context(&m_context);
+    m_context = nullptr;
+  }
+  //CLog::Log(LOGDEBUG, "CDVDVideoCodecFFmpegMMAL::{} - decoder thread stopped", __FUNCTION__);
+}
+
+void CDVDVideoCodecFFmpegMMAL::SetCodecControl(int flags)
+{
+  if (m_context)
+  {
+    if ((m_codecControlFlags & DVD_CODEC_CTRL_DROP_ANY) != (flags & DVD_CODEC_CTRL_DROP_ANY))
+    {
+      if ((flags & DVD_CODEC_CTRL_DROP_ANY) != 0)
+      {
+        m_context->skip_frame = AVDISCARD_NONREF;
+        m_context->skip_idct = AVDISCARD_NONREF;
+        m_context->skip_loop_filter = AVDISCARD_NONREF;
+      }
+      else
+      {
+        m_context->skip_frame = AVDISCARD_DEFAULT;
+        m_context->skip_idct = AVDISCARD_DEFAULT;
+        m_context->skip_loop_filter = AVDISCARD_DEFAULT;
+      }
+    }
+  }
+
+  m_codecControlFlags = flags;
+}
+
+bool CDVDVideoCodecFFmpegMMAL::GetCodecStats(double& pts, int& droppedFrames, int& skippedPics)
+{
+  if (!m_context)
+    return false;
+
+  if (m_ptsCurrent != AV_NOPTS_VALUE)
+    pts = static_cast<double>(m_ptsCurrent) * DVD_TIME_BASE / AV_TIME_BASE;
+
+  if (m_droppedFrames != -1)
+    droppedFrames = m_droppedFrames + 1;
+  else
+    droppedFrames = -1;
+  m_droppedFrames = -1;
+  skippedPics = -1;
+  return true;
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.h	2023-04-09 12:24:36.898113969 +0000
@@ -0,0 +1,83 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Thread.h"
+
+#include <memory>
+
+#define MMAL_FFMPEG_CODEC_NUM_BUFFERS (MMAL_CODEC_NUM_BUFFERS * 3 / 2)
+
+namespace MMAL
+{
+class CDVDVideoCodecFFmpegMMAL : public CDVDVideoCodec, public CThread
+{
+public:
+  explicit CDVDVideoCodecFFmpegMMAL(CProcessInfo& processInfo);
+  ~CDVDVideoCodecFFmpegMMAL() override;
+
+  static std::unique_ptr<CDVDVideoCodec> CreateCodec(CProcessInfo& processInfo);
+  static void Register();
+
+  bool Open(CDVDStreamInfo& hints, CDVDCodecOptions& options) override;
+  bool AddData(const DemuxPacket& packet) override;
+  void Reset() override;
+  CDVDVideoCodec::VCReturn GetPicture(VideoPicture* pVideoPicture) override;
+  const char* GetName() override { return m_name.c_str(); }
+  unsigned GetAllowedReferences() override { return MMAL_CODEC_NUM_BUFFERS; }
+  void SetCodecControl(int flags) override;
+  bool GetCodecStats(double& pts, int& droppedFrames, int& skippedPics) override;
+
+protected:
+  void Process() override;
+
+private:
+  static enum AVPixelFormat GetFormatCallback(struct AVCodecContext* avctx,
+                                              const enum AVPixelFormat* fmt);
+  void UpdateProcessInfo();
+  const char* GetStatusString(int status);
+  void Flush();
+
+  std::atomic<MMALCodecState> m_state{MCS_UNINITIALIZED};
+
+  std::string m_name;
+
+  AVCodecContext* m_context{nullptr};
+  AVCodec* m_codec{nullptr};
+  AVFrame* m_frame{nullptr};
+  MMALFormat m_portFormat{nullptr};
+
+  CCriticalSection m_bufferLock;
+  CCriticalSection m_queueLock;
+
+  int m_playbackSpeed{DVD_PLAYSPEED_NORMAL};
+  int m_codecControlFlags{0};
+  AVPixelFormat m_format{AV_PIX_FMT_NONE};
+
+  int64_t m_ptsCurrent{AV_NOPTS_VALUE};
+  int32_t m_droppedFrames{-1};
+
+  uint32_t m_width{0};
+  uint32_t m_height{0};
+  uint32_t m_displayWidth{0};
+  uint32_t m_displayHeight{0};
+
+  float m_fps{0.0f};
+  float m_aspect{0.0f};
+
+  std::atomic<bool> m_receive{false};
+  bool m_dropped{false};
+  CDVDStreamInfo m_hints;
+  std::shared_ptr<CVideoBufferPoolMMAL> m_bufferPool;
+};
+} // namespace MMAL
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp	2023-04-09 12:36:00.124461627 +0000
@@ -0,0 +1,923 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DVDVideoCodecMMAL.h"
+
+#include "ServiceBroker.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDCodecs.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "threads/SingleLock.h"
+#include "utils/CPUInfo.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#if defined(HAVE_DMX)
+#include "windowing/dmx/WinSystemDmx.h"
+#endif
+#include <float.h>
+
+#include <interface/mmal/mmal_events.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/vc/mmal_vc_msgs.h>
+
+extern "C"
+{
+#include <libavcodec/avcodec.h>
+#include <libavutil/error.h>
+#include <libavutil/imgutils.h>
+#include <libavutil/opt.h>
+#include <libavutil/pixdesc.h>
+}
+
+using namespace MMAL;
+
+constexpr const char* SETTING_VIDEOPLAYER_USEMMALDECODERFORHW{"videoplayer.usemmaldecoderforhw"};
+
+std::unique_ptr<CDVDVideoCodec> CDVDVideoCodecMMAL::Create(CProcessInfo& processInfo)
+{
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+          CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER))
+    return std::make_unique<CDVDVideoCodecMMAL>(processInfo);
+  return nullptr;
+}
+
+void CDVDVideoCodecMMAL::Register()
+{
+  auto settingsComponent = CServiceBroker::GetSettingsComponent();
+  if (!settingsComponent)
+    return;
+
+  auto settings = settingsComponent->GetSettings();
+  if (!settings)
+    return;
+
+  auto setting = settings->GetSetting(CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER);
+  if (!setting)
+  {
+    CLog::Log(LOGERROR, "Failed to load setting for: {}",
+              CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER);
+    return;
+  }
+  setting->SetVisible(true);
+
+  setting = settings->GetSetting(SETTING_VIDEOPLAYER_USEMMALDECODERFORHW);
+  if (!setting)
+  {
+    CLog::Log(LOGERROR, "Failed to load setting for: {}", SETTING_VIDEOPLAYER_USEMMALDECODERFORHW);
+    return;
+  }
+  setting->SetVisible(true);
+
+  CDVDFactoryCodec::RegisterHWVideoCodec("mmal", CDVDVideoCodecMMAL::Create);
+}
+
+void CDVDVideoCodecMMAL::ProcessControlCallback(MMALPort port, MMALBufferHeader header)
+{
+  CDVDVideoCodecMMAL* codec = static_cast<CDVDVideoCodecMMAL*>((void*)port->userdata);
+  if (codec && header->cmd == MMAL_EVENT_ERROR)
+  {
+    MMALStatus status = *(MMALStatus*)header->data;
+    if (status != MMAL_EAGAIN)
+    {
+      codec->m_state = MCS_ERROR;
+      CLog::Log(LOGWARNING, "CDVDVideoCodecMMAL::{} - decoder error reported: {}", __FUNCTION__,
+                mmal_status_to_string(status));
+    }
+  }
+  mmal_buffer_header_release(header);
+}
+
+void CDVDVideoCodecMMAL::ProcessInputCallback(MMALPort port, MMALBufferHeader header)
+{
+  mmal_buffer_header_release(header);
+}
+
+void CDVDVideoCodecMMAL::ProcessOutputCallback(MMALPort port, MMALBufferHeader header)
+{
+  CDVDVideoCodecMMAL* codec = static_cast<CDVDVideoCodecMMAL*>((void*)port->userdata);
+  if (codec)
+  {
+    CVideoBufferMMAL* buffer = nullptr;
+    if (header->cmd == MMAL_EVENT_FORMAT_CHANGED)
+    {
+      if (mmal_buffer_header_mem_lock(header) == MMAL_SUCCESS)
+      {
+        MMALFormatChangedEventArgs args = mmal_event_format_changed_get(header);
+        if (mmal_format_full_copy(codec->m_output->format, args->format) == MMAL_SUCCESS)
+        {
+          const MMAL_VIDEO_FORMAT_T* videoFormat = &codec->m_portFormat->es->video;
+          if (videoFormat->crop.width > 0 && videoFormat->crop.height > 0)
+          {
+            codec->m_output->format->es->video.crop.width = videoFormat->crop.width;
+            codec->m_output->format->es->video.crop.height = videoFormat->crop.height;
+          }
+          if (codec->m_output->format->es->video.frame_rate.num == 0 ||
+              codec->m_output->format->es->video.frame_rate.den == 0)
+          {
+            codec->m_output->format->es->video.frame_rate.num = videoFormat->frame_rate.num;
+            codec->m_output->format->es->video.frame_rate.den = videoFormat->frame_rate.den;
+          }
+
+          if (codec->m_hints.forced_aspect)
+          {
+            codec->m_output->format->es->video.par.num = videoFormat->par.num;
+            codec->m_output->format->es->video.par.den = videoFormat->par.den;
+          }
+
+          if (codec->m_output->format->es->video.color_space == MMAL_COLOR_SPACE_UNKNOWN)
+            codec->m_output->format->es->video.color_space =
+                CVideoBufferPoolMMAL::TranslateColorSpace(codec->m_hints.colorSpace);
+          std::unique_lock<CCriticalSection> lock(codec->m_outputPortLock);
+          if (mmal_port_format_commit(codec->m_output) == MMAL_SUCCESS)
+          {
+            codec->m_output->buffer_num = MMAL_CODEC_NUM_BUFFERS;
+            codec->m_output->buffer_size = args->buffer_size_recommended;
+            if (mmal_format_full_copy(codec->m_portFormat, codec->m_output->format) == MMAL_SUCCESS)
+              codec->UpdateProcessInfo();
+          }
+          else
+            CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to commit port format",
+                      __FUNCTION__);
+        }
+        else
+          CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to copy port format", __FUNCTION__);
+        mmal_buffer_header_mem_unlock(header);
+      }
+      else
+        CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to lock memory", __FUNCTION__);
+    }
+    if ((header->flags & MMAL_BUFFER_HEADER_FLAG_ZEROCOPY) != 0 &&
+        (buffer = static_cast<CVideoBufferMMAL*>(header->user_data)) != NULL)
+    {
+      MMALCodecState state = codec->m_state;
+      if (header->cmd == 0 &&
+          (state == MCS_DECODING || state == MCS_OPENED || state == MCS_FLUSHED ||
+           state == MCS_FLUSHING || state == MCS_CLOSING))
+      {
+        if ((header->flags & MMAL_BUFFER_HEADER_FLAG_EOS) == 0)
+        {
+          codec->m_ptsCurrent = buffer->GetHeader()->pts;
+          codec->m_bufferPool->Put(buffer);
+        }
+        else if (state == MCS_CLOSING)
+        {
+          buffer->Release();
+          codec->Close();
+        }
+        else
+          buffer->Release();
+      }
+      else
+        buffer->Release();
+    }
+    else
+      mmal_buffer_header_release(header);
+  }
+  else
+    mmal_buffer_header_release(header);
+}
+
+CDVDVideoCodecMMAL::CDVDVideoCodecMMAL(CProcessInfo& processInfo) : CDVDVideoCodec(processInfo)
+{
+  MMALStatus status = MMAL_SUCCESS;
+  m_name = "mmal";
+  m_codecName = "    ";
+
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &m_component);
+  if (status == MMAL_SUCCESS)
+  {
+    m_bufferPool = std::make_shared<CVideoBufferPoolMMAL>();
+    if (m_component->is_enabled != 0)
+      mmal_component_disable(m_component);
+
+    int* priority = (int*)((uint8_t*)m_component->priv + 28);
+    *priority = VCOS_THREAD_PRI_ABOVE_NORMAL;
+
+    m_component->control->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+    status = mmal_port_enable(m_component->control, CDVDVideoCodecMMAL::ProcessControlCallback);
+    if (status == MMAL_SUCCESS)
+    {
+      MMAL_PARAMETER_HEADER_T* parameter = nullptr;
+      m_input = m_component->input[0];
+      m_output = m_component->output[0];
+      m_input->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+      m_output->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+      m_portFormat = mmal_format_alloc();
+      m_portFormat->extradata = nullptr;
+      m_portFormat->extradata_size = 0;
+      m_format = AV_PIX_FMT_NONE;
+
+      mmal_port_parameter_set_boolean(m_input, MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT,
+                                      MMAL_TRUE);
+      mmal_port_parameter_set_uint32(m_input, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+      mmal_port_parameter_set_boolean(m_input, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+      mmal_port_parameter_set_boolean(m_input, MMAL_PARAMETER_NO_IMAGE_PADDING, MMAL_TRUE);
+      mmal_port_parameter_set_boolean(m_input, MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO, MMAL_TRUE);
+
+      mmal_port_parameter_set_uint32(m_output, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+      mmal_port_parameter_set_boolean(m_output, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+      mmal_port_parameter_set_boolean(m_output, MMAL_PARAMETER_NO_IMAGE_PADDING, MMAL_TRUE);
+
+      parameter =
+          mmal_port_parameter_alloc_get(m_input, MMAL_PARAMETER_SUPPORTED_ENCODINGS, 0, &status);
+      if (status == MMAL_SUCCESS)
+      {
+        uint32_t* codecs = (uint32_t*)((uint8_t*)parameter + sizeof(*parameter));
+        char buf[5] = {0, 0, 0, 0, 0};
+        for (uint32_t i = 0; i < 16; i++)
+        {
+          if (i < (parameter->size - sizeof(*parameter)) / 4)
+            m_supportedCodecs[i] = codecs[i];
+          else
+            m_supportedCodecs[i] = MMAL_ENCODING_UNKNOWN;
+        }
+        mmal_port_parameter_free(parameter);
+      }
+      m_state = MCS_INITIALIZED;
+      return;
+    }
+  }
+  CLog::Log(LOGERROR, "Failed to create component");
+  m_state = MCS_UNINITIALIZED;
+}
+
+CDVDVideoCodecMMAL::~CDVDVideoCodecMMAL()
+{
+  if (m_state != MCS_INITIALIZED)
+  {
+    if (m_state != MCS_CLOSED)
+      Close(true);
+  }
+
+  if (m_input)
+  {
+    m_input->userdata = nullptr;
+    std::unique_lock<CCriticalSection> lock(m_inputSendLock);
+    if (m_inputPool && mmal_queue_length(m_inputPool->queue) >= m_inputPool->headers_num)
+    {
+      mmal_pool_destroy(m_inputPool);
+      m_inputPool = nullptr;
+    }
+    m_input = nullptr;
+  }
+
+  if (m_output)
+  {
+    m_output->userdata = nullptr;
+    m_output = nullptr;
+  }
+
+  if (m_component->control->is_enabled != 0)
+  {
+    if (mmal_port_disable(m_component->control) == MMAL_SUCCESS)
+      m_component->control->userdata = nullptr;
+    else
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to disable control port", __FUNCTION__);
+  }
+
+  if (m_bufferPool)
+  {
+    m_bufferPool->Dispose();
+    m_bufferPool = nullptr;
+  }
+
+  if (m_portFormat)
+  {
+    mmal_format_free(m_portFormat);
+    m_portFormat = nullptr;
+  }
+
+  if (mmal_component_release(m_component) != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to release component", __FUNCTION__);
+
+  m_component = nullptr;
+  m_state = MCS_UNINITIALIZED;
+}
+
+void CDVDVideoCodecMMAL::BufferReleaseCallback(CVideoBufferPoolMMAL* pool,
+                                               CVideoBufferMMAL* buffer,
+                                               void* userdata)
+{
+  CDVDVideoCodecMMAL* codec = static_cast<CDVDVideoCodecMMAL*>(userdata);
+  if (codec)
+  {
+    MMALCodecState state = codec->m_state;
+    if (state != MCS_CLOSED && state != MCS_ERROR)
+    {
+      MMALBufferHeader header = buffer->GetHeader();
+      if (header)
+      {
+        std::unique_lock<CCriticalSection> slock(codec->m_outputSendLock);
+        mmal_buffer_header_reset(header);
+        header->cmd = 0;
+
+        if (mmal_port_send_buffer(codec->m_output, header) != MMAL_SUCCESS)
+          CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to send buffer", __FUNCTION__);
+      }
+    }
+  }
+}
+
+void CDVDVideoCodecMMAL::UpdateProcessInfo()
+{
+  m_format = CVideoBufferPoolMMAL::TranslatePortFormat(m_portFormat->encoding);
+  const char* pixFmtName = av_get_pix_fmt_name(m_format);
+  mmal_4cc_to_string(&m_codecName[0], m_codecName.size(), m_portFormat->encoding);
+  m_name = StringUtils::TrimRight(m_codecName) + std::string("-mmal");
+  StringUtils::ToLower(m_name);
+
+  m_fps = 0.0f;
+  m_aspect = 0.0f;
+  if (m_portFormat->es->video.frame_rate.num > 0 && m_portFormat->es->video.frame_rate.den > 0)
+    m_fps = (float)m_portFormat->es->video.frame_rate.num /
+            (float)m_portFormat->es->video.frame_rate.den;
+
+  if (m_portFormat->es->video.par.num > 0 && m_portFormat->es->video.par.den > 0)
+    m_aspect = (float)m_portFormat->es->video.par.num / (float)m_portFormat->es->video.par.den;
+
+  if (m_portFormat->es->video.crop.width > 0 && m_portFormat->es->video.crop.height > 0)
+  {
+    m_width = m_portFormat->es->video.crop.width;
+    m_height = m_portFormat->es->video.crop.height;
+  }
+  else
+  {
+    m_width = m_portFormat->es->video.width;
+    m_height = m_portFormat->es->video.height;
+  }
+
+  if (m_aspect > 0.0f)
+  {
+    m_displayWidth = (static_cast<uint32_t>(lrint(m_height * m_aspect))) & -3;
+    m_displayHeight = m_height;
+    if (m_displayWidth > m_width)
+    {
+      m_displayWidth = m_width;
+      m_displayHeight = (static_cast<uint32_t>(lrint(m_width / m_aspect))) & -3;
+    }
+  }
+  else
+  {
+    m_displayWidth = m_width;
+    m_displayHeight = m_height;
+  }
+
+  VideoPicture picture{};
+
+  picture.Reset();
+
+  picture.hasDisplayMetadata = false;
+  picture.hasLightMetadata = false;
+
+  picture.pixelFormat = m_format;
+
+  picture.iWidth = m_width;
+  picture.iHeight = m_height;
+  picture.iDisplayWidth = m_displayWidth;
+  picture.iDisplayHeight = m_displayHeight;
+
+  picture.color_range = m_hints.colorRange == AVCOL_RANGE_JPEG;
+  picture.color_primaries = m_hints.colorPrimaries;
+  picture.color_transfer = m_hints.colorTransferCharacteristic;
+  picture.color_space = m_hints.colorSpace;
+  picture.colorBits = m_hints.bitsperpixel;
+
+  if (m_hints.masteringMetadata)
+  {
+    picture.displayMetadata = *m_hints.masteringMetadata.get();
+    picture.hasDisplayMetadata = true;
+  }
+
+  if (m_hints.contentLightMetadata)
+  {
+    picture.lightMetadata = *m_hints.contentLightMetadata.get();
+    picture.hasLightMetadata = true;
+  }
+
+  m_bufferPool->SetReleaseCallback(CDVDVideoCodecMMAL::BufferReleaseCallback, this);
+  m_bufferPool->Configure(m_portFormat, &picture, m_output->buffer_num, m_output->buffer_size);
+
+  std::list<EINTERLACEMETHOD> intMethods;
+  intMethods.push_back(VS_INTERLACEMETHOD_NONE);
+  m_processInfo.UpdateDeinterlacingMethods(intMethods);
+
+  m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
+  m_processInfo.SetVideoDimensions(m_width, m_height);
+  m_processInfo.SetVideoDecoderName(m_name, true);
+  m_processInfo.SetVideoDeintMethod("none");
+  m_processInfo.SetVideoStereoMode("mono");
+  m_processInfo.SetVideoDAR(m_aspect);
+  m_processInfo.SetVideoFps(m_fps);
+
+  m_state = MCS_DECODING;
+}
+
+bool CDVDVideoCodecMMAL::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
+{
+  if (m_state != MCS_INITIALIZED)
+    return false;
+
+  uint32_t encoding = CVideoBufferPoolMMAL::TranslateCodec(hints.codec);
+
+  if (encoding != MMAL_ENCODING_UNKNOWN)
+  {
+    uint32_t codec = MMAL_ENCODING_UNKNOWN;
+    for (int i = 0; i < 15; i++)
+    {
+      if (m_supportedCodecs[i] == encoding)
+      {
+        codec = encoding;
+        break;
+      }
+    }
+    encoding = codec;
+  }
+
+  if (encoding == MMAL_ENCODING_UNKNOWN)
+  {
+    CLog::Log(LOGDEBUG, "CDVDVideoCodecMMAL::{} - unsupported codec", __FUNCTION__);
+    return false;
+  }
+
+  bool configureCodec = true;
+  MMALStatus status = MMAL_SUCCESS;
+
+  m_input->format->type = MMAL_ES_TYPE_VIDEO;
+  m_input->format->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
+  m_input->format->encoding = encoding;
+  m_input->format->es->video.width = hints.width;
+  m_input->format->es->video.height = hints.height;
+  m_input->format->es->video.frame_rate.num = hints.fpsrate;
+  m_input->format->es->video.frame_rate.den = hints.fpsscale;
+  m_input->format->es->video.par.num = 1;
+  m_input->format->es->video.par.den = 1;
+
+  if (hints.aspect > 0)
+  {
+    double delta = DBL_MAX;
+    int w = 1, h = 1;
+    for (int i = 0; i < 127; i++)
+    {
+      double d = (double)w / (double)h - hints.aspect;
+      if (d < 0)
+        d = abs(((double)++w / (double)h) - hints.aspect);
+      else
+        d = abs(((double)w / (double)++h) - hints.aspect);
+      if (d < delta)
+      {
+        delta = d;
+        m_input->format->es->video.par.num = w;
+        m_input->format->es->video.par.den = h;
+      }
+    }
+  }
+
+  if (configureCodec && hints.extradata && hints.extrasize > 0)
+  {
+    if (hints.extrasize < MMAL_FORMAT_EXTRADATA_MAX_SIZE &&
+        mmal_format_extradata_alloc(m_input->format, hints.extrasize) == MMAL_SUCCESS)
+    {
+      m_input->format->extradata_size = hints.extrasize;
+      memcpy(m_input->format->extradata, hints.extradata, hints.extrasize);
+      configureCodec = false;
+    }
+  }
+
+  mmal_port_parameter_set_boolean(m_input, MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS,
+                                  hints.ptsinvalid ? MMAL_TRUE : MMAL_FALSE);
+
+  mmal_port_parameter_set_uint32(m_input, MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, -10);
+
+  if (mmal_port_format_commit(m_input) != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to commit codec format", __FUNCTION__);
+    return false;
+  }
+
+  m_input->buffer_num = 24;
+  m_input->buffer_size = 4096 * 24; //1024 * 64;
+
+  if (m_input->buffer_alignment_min > 0)
+    m_input->buffer_size = VCOS_ALIGN_UP(m_input->buffer_size, m_input->buffer_alignment_min);
+
+  m_inputPool = mmal_port_pool_create(m_input, m_input->buffer_num, m_input->buffer_size);
+
+  if (!m_inputPool)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to create codec buffer pool",
+              __FUNCTION__);
+    return false;
+  }
+
+  m_output->format->type = MMAL_ES_TYPE_VIDEO;
+  m_output->format->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
+  m_output->format->encoding = MMAL_ENCODING_UNKNOWN;
+  m_output->format->encoding_variant = MMAL_ENCODING_UNKNOWN;
+  m_output->format->es->video.width = m_input->format->es->video.width;
+  m_output->format->es->video.height = m_input->format->es->video.height;
+  m_output->format->es->video.frame_rate.num = m_input->format->es->video.frame_rate.num;
+  m_output->format->es->video.frame_rate.den = m_input->format->es->video.frame_rate.den;
+  m_output->format->es->video.color_space = MMAL_COLOR_SPACE_UNKNOWN;
+
+  if (hints.forced_aspect)
+  {
+    m_output->format->es->video.par.num = m_input->format->es->video.par.num;
+    m_output->format->es->video.par.den = m_input->format->es->video.par.den;
+  }
+
+  if (m_input->format->es->video.width < m_output->format->es->video.width)
+    m_output->format->es->video.crop.width = m_input->format->es->video.width;
+  if (m_input->format->es->video.height < m_output->format->es->video.height)
+    m_output->format->es->video.crop.height = m_input->format->es->video.height;
+
+  if (mmal_port_format_commit(m_output) != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to commit port format", __FUNCTION__);
+    return false;
+  }
+
+  if (mmal_format_full_copy(m_portFormat, m_output->format) != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to copy port format", __FUNCTION__);
+    return false;
+  }
+
+  m_output->buffer_num = MMAL_CODEC_NUM_BUFFERS;
+  m_output->buffer_size = m_output->buffer_size_recommended;
+
+  if (mmal_port_enable(m_input, CDVDVideoCodecMMAL::ProcessInputCallback) != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to enable input port", __FUNCTION__);
+    return false;
+  }
+
+  if (mmal_port_enable(m_output, CDVDVideoCodecMMAL::ProcessOutputCallback) != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to enable output port", __FUNCTION__);
+    return false;
+  }
+
+  if (m_component->is_enabled == 0)
+  {
+    if (mmal_component_enable(m_component) != MMAL_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to enable component", __FUNCTION__);
+      return false;
+    }
+  }
+
+  if (configureCodec)
+  {
+    if (!ConfigureCodec((uint8_t*)hints.extradata, hints.extrasize))
+      return false;
+  }
+
+  m_hints = hints;
+  m_state = MCS_OPENED;
+
+  return true;
+}
+
+bool CDVDVideoCodecMMAL::ConfigureCodec(uint8_t* extraData, uint32_t extraSize)
+{
+  uint32_t size = extraSize;
+  uint8_t* data = extraData;
+
+  std::unique_lock<CCriticalSection> lock(m_inputSendLock);
+  MMALBufferHeader header = nullptr;
+  while (size > 0 && (header = mmal_queue_get(m_inputPool->queue)) != NULL)
+  {
+    mmal_buffer_header_reset(header);
+    header->cmd = 0;
+    header->flags = MMAL_BUFFER_HEADER_FLAG_CONFIG;
+
+    if (size > header->alloc_size)
+      header->length = header->alloc_size;
+    else
+      header->length = size;
+
+    if (data)
+    {
+      mmal_buffer_header_mem_lock(header);
+      memcpy(header->data, data, header->length);
+      mmal_buffer_header_mem_unlock(header);
+    }
+
+    size -= header->length;
+    data += header->length;
+
+    if (size == 0)
+      header->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+    if (mmal_port_send_buffer(m_input, header) != MMAL_SUCCESS)
+    {
+      m_state = MCS_ERROR;
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - failed to configure codec", __FUNCTION__);
+      return false;
+    }
+  }
+  return true;
+}
+
+bool CDVDVideoCodecMMAL::SendEndOfStream()
+{
+  MMALCodecState state = m_state;
+
+  if (state == MCS_DECODING)
+  {
+    std::unique_lock<CCriticalSection> lock(m_inputSendLock);
+    MMALBufferHeader header = mmal_queue_get(m_inputPool->queue);
+    mmal_buffer_header_reset(header);
+    header->cmd = 0;
+    header->flags = MMAL_BUFFER_HEADER_FLAG_EOS;
+    header->length = 0;
+    m_state = MCS_CLOSING;
+    if (mmal_port_send_buffer(m_input, header) != MMAL_SUCCESS)
+    {
+      m_state = state;
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to send eos signal", __FUNCTION__);
+      return false;
+    }
+  }
+  return true;
+}
+
+bool CDVDVideoCodecMMAL::AddData(const DemuxPacket& packet)
+{
+  uint32_t size = (uint32_t)packet.iSize;
+  uint8_t* data = packet.pData;
+  MMALCodecState state = m_state;
+
+  if (state == MCS_FLUSHING || state == MCS_ERROR)
+    return false;
+  else if (state == MCS_CLOSING || state == MCS_CLOSED)
+    return true;
+  else if (data == nullptr || size == 0)
+    return SendEndOfStream();
+
+  uint32_t freeBytes = m_input->buffer_size * (mmal_queue_length(m_inputPool->queue) - 1);
+  if (size > freeBytes)
+  {
+    m_rejectedSize = size;
+    return false;
+  }
+  else
+    m_rejectedSize = 0;
+
+  std::unique_lock<CCriticalSection> lock(m_inputSendLock);
+  int64_t ptsPacket = MMAL_TIME_UNKNOWN;
+  int64_t dtsPacket = MMAL_TIME_UNKNOWN;
+
+  if (packet.dts != DVD_NOPTS_VALUE)
+    dtsPacket = static_cast<int64_t>(packet.dts / DVD_TIME_BASE * AV_TIME_BASE);
+
+  if (!m_hints.ptsinvalid && packet.pts != DVD_NOPTS_VALUE)
+    ptsPacket = static_cast<int64_t>(packet.pts / DVD_TIME_BASE * AV_TIME_BASE);
+
+  MMALStatus status = MMAL_SUCCESS;
+  MMALBufferHeader header = nullptr;
+  while (size > 0 && (header = mmal_queue_get(m_inputPool->queue)) != NULL)
+  {
+    mmal_buffer_header_reset(header);
+    header->cmd = 0;
+    header->flags = MMAL_BUFFER_HEADER_FLAG_ZEROCOPY;
+
+    header->pts = ptsPacket;
+    header->dts = dtsPacket;
+
+    if (size == (uint32_t)packet.iSize)
+    {
+      if (state == MCS_FLUSHED)
+      {
+        m_state = MCS_DECODING;
+        header->flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
+      }
+      else if ((m_codecControlFlags & DVD_CODEC_CTRL_DROP) != 0)
+      {
+        header->flags |= MMAL_BUFFER_HEADER_FLAG_DECODEONLY;
+        m_dropped = true;
+        m_droppedFrames++;
+      }
+      else if (m_dropped)
+      {
+        header->flags |= MMAL_BUFFER_HEADER_FLAG_SEEK;
+        m_dropped = false;
+      }
+      header->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;
+    }
+
+    if (size > header->alloc_size)
+      header->length = header->alloc_size;
+    else
+      header->length = size;
+
+    if (data)
+    {
+      if (mmal_buffer_header_mem_lock(header) == MMAL_SUCCESS)
+      {
+        memcpy(header->data, data, header->length);
+        mmal_buffer_header_mem_unlock(header);
+      }
+      else
+      {
+        CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to lock memory", __FUNCTION__);
+        m_state = MCS_RESET;
+        return false;
+      }
+    }
+
+    size -= header->length;
+    data += header->length;
+
+    if (size == 0)
+      header->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+    status = mmal_port_send_buffer(m_input, header);
+
+    if (status == MMAL_EAGAIN)
+      status = mmal_port_send_buffer(m_input, header);
+
+    if (status != MMAL_SUCCESS)
+    {
+      m_state = MCS_RESET;
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to send buffer to input port",
+                __FUNCTION__);
+      return false;
+    }
+  }
+  if (size == 0)
+    return true;
+
+  m_state = MCS_RESET;
+  CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to send complete frame", __FUNCTION__);
+  return false;
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecMMAL::GetPicture(VideoPicture* pVideoPicture)
+{
+  CDVDVideoCodec::VCReturn result = VC_NONE;
+  MMALCodecState state = m_state;
+
+  if (state == MCS_INITIALIZED || state == MCS_UNINITIALIZED)
+  {
+    result = VC_ERROR;
+  }
+  else if (state == MCS_CLOSED || state == MCS_ERROR)
+  {
+    result = VC_EOF;
+  }
+  else if (state == MCS_OPENED)
+  {
+    result = VC_BUFFER;
+  }
+  else if (state == MCS_RESET)
+  {
+    result = VC_FLUSHED;
+  }
+  else
+  {
+    CVideoBufferMMAL* buffer = nullptr;
+    uint32_t rendered = m_bufferPool->Length(true);
+    uint32_t inputFree = mmal_queue_length(m_inputPool->queue);
+    uint32_t renderLimit = (static_cast<float>(inputFree - 1) / (m_inputPool->headers_num - 1)) *
+                           MMAL_CODEC_NUM_BUFFERS;
+    bool receive = rendered <= MMAL_CODEC_NUM_BUFFERS && inputFree > 1 &&
+                   (m_input->buffer_size * (inputFree - 1)) > m_rejectedSize;
+    bool drain = state == MCS_CLOSING || state == MCS_FLUSHING || state == MCS_FLUSHED ||
+                 (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0 ||
+                 (m_codecControlFlags & DVD_CODEC_CTRL_DROP_ANY) != 0;
+
+    if (rendered > 0 && (drain || rendered >= renderLimit) &&
+        (buffer = dynamic_cast<CVideoBufferMMAL*>(m_bufferPool->Get(true))) != NULL)
+    {
+      bool drop = (m_codecControlFlags & DVD_CODEC_CTRL_DROP) != 0;
+
+      pVideoPicture->Reset();
+      pVideoPicture->SetParams(buffer->GetPicture());
+
+      pVideoPicture->iFlags |= m_codecControlFlags;
+
+      if (drop && (pVideoPicture->iFlags & DVP_FLAG_DROPPED) == 0)
+        pVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+
+      if ((pVideoPicture->iFlags & DVD_CODEC_CTRL_DRAIN) != 0)
+        pVideoPicture->iFlags &= ~DVD_CODEC_CTRL_DRAIN;
+
+      pVideoPicture->videoBuffer = buffer;
+
+      result = VC_PICTURE;
+    }
+    else if (state != MCS_CLOSING && receive)
+    {
+      if ((m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0)
+        m_codecControlFlags &= ~DVD_CODEC_CTRL_DRAIN;
+      result = VC_BUFFER;
+    }
+    else if (state == MCS_CLOSING && inputFree >= m_inputPool->headers_num)
+    {
+      result = VC_EOF;
+      m_state = MCS_CLOSED;
+    }
+  }
+  return result;
+}
+
+bool CDVDVideoCodecMMAL::Close(bool force)
+{
+  MMALCodecState state = m_state;
+  if (state == MCS_CLOSING || force)
+  {
+    m_state = MCS_CLOSED;
+    if (m_input->is_enabled != 0)
+    {
+      std::unique_lock<CCriticalSection> iplock(m_inputPortLock);
+      if (mmal_port_disable(m_input) == MMAL_SUCCESS)
+        m_input->userdata = nullptr;
+      else
+        CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to disable input port", __FUNCTION__);
+    }
+
+    m_bufferPool->Flush();
+    m_bufferPool->SetReleaseCallback();
+
+    if (m_output->is_enabled != 0)
+    {
+      std::unique_lock<CCriticalSection> oplock(m_outputPortLock);
+      if (mmal_port_disable(m_output) == MMAL_SUCCESS)
+        m_output->userdata = nullptr;
+      else
+        CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to disable output port", __FUNCTION__);
+    }
+
+    m_ptsCurrent = MMAL_TIME_UNKNOWN;
+    m_droppedFrames = -1;
+
+    if (m_component->is_enabled != 0)
+    {
+      if (mmal_component_disable(m_component) != MMAL_SUCCESS)
+        CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to disable component", __FUNCTION__);
+    }
+  }
+  return true;
+}
+
+void CDVDVideoCodecMMAL::Reset()
+{
+  MMALCodecState state = m_state;
+  if (state == MCS_DECODING)
+  {
+    m_state = MCS_FLUSHING;
+    std::unique_lock<CCriticalSection> ilock(m_inputSendLock);
+    if (mmal_port_flush(m_input) != MMAL_SUCCESS)
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to flush input port", __FUNCTION__);
+    ilock.unlock();
+    m_bufferPool->Flush();
+    std::unique_lock<CCriticalSection> olock(m_outputSendLock);
+    if (mmal_port_flush(m_output) != MMAL_SUCCESS)
+      CLog::Log(LOGERROR, "CDVDVideoCodecMMAL::{} - unable to flush output port", __FUNCTION__);
+    olock.unlock();
+
+    m_ptsCurrent = MMAL_TIME_UNKNOWN;
+    m_droppedFrames = -1;
+    m_dropped = false;
+    if ((m_codecControlFlags & DVD_CODEC_CTRL_DRAIN) != 0)
+      m_codecControlFlags &= ~DVD_CODEC_CTRL_DRAIN;
+    m_state = MCS_FLUSHED;
+  }
+}
+
+void CDVDVideoCodecMMAL::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
+
+void CDVDVideoCodecMMAL::SetSpeed(int iSpeed)
+{
+  m_playbackSpeed = iSpeed;
+}
+
+bool CDVDVideoCodecMMAL::GetCodecStats(double& pts, int& droppedFrames, int& skippedPics)
+{
+  if (m_ptsCurrent != MMAL_TIME_UNKNOWN)
+  {
+    pts = static_cast<double>(m_ptsCurrent) * DVD_TIME_BASE / AV_TIME_BASE;
+  }
+
+  if (m_droppedFrames != -1)
+    droppedFrames = m_droppedFrames + 1;
+  else
+    droppedFrames = -1;
+  m_droppedFrames = -1;
+  skippedPics = -1;
+  return true;
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h	2023-04-06 20:10:10.063831399 +0000
@@ -0,0 +1,121 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+#include "cores/VideoPlayer/Buffers/VideoBufferMMAL.h"
+#include "cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "threads/Event.h"
+
+#include <atomic>
+#include <memory>
+
+#include <interface/mmal/mmal.h>
+
+#define MMAL_CODEC_NUM_BUFFERS 4
+
+namespace MMAL
+{
+typedef MMAL_EVENT_FORMAT_CHANGED_T* MMALFormatChangedEventArgs;
+typedef MMAL_EVENT_END_OF_STREAM_T* MMALEndOfStreamEventArgs;
+typedef MMAL_EVENT_PARAMETER_CHANGED_T* MMALParameterChangedEventArgs;
+
+enum MMALCodecState
+{
+  MCS_UNINITIALIZED = 0, // 0
+  MCS_INITIALIZED, // 1 x
+  MCS_OPENED, // 2 x
+  MCS_DECODING, // 3
+  MCS_FLUSHING, // 4 x
+  MCS_FLUSHED, // 5 x
+  MCS_CLOSING, // 6
+  MCS_CLOSED, // 7
+  MCS_RESET,
+  MCS_ERROR, // 8
+};
+
+class CDVDVideoCodecMMAL : public CDVDVideoCodec
+{
+public:
+  explicit CDVDVideoCodecMMAL(CProcessInfo& processInfo);
+  ~CDVDVideoCodecMMAL() override;
+
+  static std::unique_ptr<CDVDVideoCodec> Create(CProcessInfo& processInfo);
+  static void Register();
+
+  bool Open(CDVDStreamInfo& hints, CDVDCodecOptions& options) override;
+  bool AddData(const DemuxPacket& packet) override;
+  void Reset() override;
+  CDVDVideoCodec::VCReturn GetPicture(VideoPicture* pVideoPicture) override;
+  const char* GetName() override { return m_name.c_str(); }
+  unsigned GetAllowedReferences() override { return MMAL_CODEC_NUM_BUFFERS; }
+  void SetCodecControl(int flags) override;
+  void SetSpeed(int iSpeed) override;
+  bool GetCodecStats(double& pts, int& droppedFrames, int& skippedPics) override;
+
+private:
+  static void ProcessControlCallback(MMALPort port, MMALBufferHeader header);
+  static void ProcessInputCallback(MMALPort port, MMALBufferHeader header);
+  static void ProcessOutputCallback(MMALPort port, MMALBufferHeader header);
+  static void BufferReleaseCallback(CVideoBufferPoolMMAL* pool,
+                                    CVideoBufferMMAL* buffer,
+                                    void* userdata);
+
+  bool Close(bool force = false);
+  bool ConfigureCodec(uint8_t* extraData, uint32_t extraDataSize);
+
+  bool SendEndOfStream();
+  void UpdateProcessInfo();
+
+  std::atomic<MMALCodecState> m_state{MCS_UNINITIALIZED};
+
+  std::string m_name;
+  std::string m_codecName;
+  MMALComponent m_component;
+
+  MMALPort m_input{nullptr};
+  MMALPool m_inputPool{nullptr};
+  CCriticalSection m_inputPortLock;
+  CCriticalSection m_inputSendLock;
+
+  MMALPort m_output{nullptr};
+  MMALFormat m_portFormat{nullptr};
+  CCriticalSection m_outputPortLock;
+  CCriticalSection m_outputSendLock;
+
+  int m_playbackSpeed{DVD_PLAYSPEED_NORMAL};
+  int m_codecControlFlags{0};
+  AVPixelFormat m_format{AV_PIX_FMT_NONE};
+
+  int64_t m_ptsCurrent{MMAL_TIME_UNKNOWN};
+  int32_t m_droppedFrames{-1};
+
+  uint32_t m_rejectedSize{0};
+
+  uint32_t m_width{0};
+  uint32_t m_height{0};
+  uint32_t m_displayWidth{0};
+  uint32_t m_displayHeight{0};
+
+  uint32_t m_supportedCodecs[16]{0};
+
+  float m_fps{0.0f};
+  float m_aspect{0.0f};
+
+  uint32_t m_fpsRate{0};
+  uint32_t m_fpsScale{0};
+
+  bool m_dropped{false};
+
+  CDVDStreamInfo m_hints;
+  std::shared_ptr<CVideoBufferPoolMMAL> m_bufferPool;
+};
+} // namespace MMAL
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/CMakeLists.txt	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,4 @@
+set(SOURCES ProcessInfoDmx.cpp)
+set(HEADERS ProcessInfoDmx.h)
+
+core_add_library(processdmx)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.cpp	2023-04-08 17:47:01.194733190 +0000
@@ -0,0 +1,80 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "ProcessInfoDmx.h"
+
+#include "cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h"
+
+using namespace VIDEOPLAYER;
+
+CProcessInfo* CProcessInfoDmx::Create()
+{
+  return new CProcessInfoDmx();
+}
+
+void CProcessInfoDmx::Register()
+{
+  CProcessInfo::RegisterProcessControl("dmx", CProcessInfoDmx::Create);
+}
+
+CProcessInfoDmx::CProcessInfoDmx()
+{
+  m_videoBufferManager.RegisterPool(std::make_shared<MMAL::CVideoBufferPoolMMAL>());
+}
+
+EINTERLACEMETHOD CProcessInfoDmx::GetFallbackDeintMethod()
+{
+#if defined(__arm__)
+  return EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE_HALF;
+#else
+  return CProcessInfo::GetFallbackDeintMethod();
+#endif
+}
+std::vector<AVPixelFormat> CProcessInfoDmx::GetRenderFormats()
+{
+  std::vector<AVPixelFormat> formats;
+  formats.push_back(AV_PIX_FMT_YUV420P);
+  formats.push_back(AV_PIX_FMT_YUVJ420P);
+  formats.push_back(AV_PIX_FMT_YUV420P10);
+  formats.push_back(AV_PIX_FMT_YUV420P12);
+  formats.push_back(AV_PIX_FMT_YUV420P14);
+  formats.push_back(AV_PIX_FMT_YUV420P16);
+  formats.push_back(AV_PIX_FMT_SAND128);
+  formats.push_back(AV_PIX_FMT_SAND64_10);
+  formats.push_back(AV_PIX_FMT_SAND64_16);
+  return formats;
+}
+
+/*
+std::vector<AVPixelFormat> CProcessInfoDmx::GetRenderFormats()
+{
+  return
+  {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_YUVJ420P,
+    AV_PIX_FMT_YUV420P10,
+    AV_PIX_FMT_YUV420P12,
+    AV_PIX_FMT_YUV420P14,
+    AV_PIX_FMT_YUV420P16,
+    AV_PIX_FMT_RGBA,
+    AV_PIX_FMT_RGB0,
+    AV_PIX_FMT_BGRA,
+    AV_PIX_FMT_BGR0,
+    AV_PIX_FMT_RGB24,
+    AV_PIX_FMT_BGR24,
+    AV_PIX_FMT_RGB565,
+    AV_PIX_FMT_BGR565,
+  };
+}
+*/
+/*
+bool CProcessInfoDmx::AllowDTSHDDecode()
+{
+  return true;
+}
+*/
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/Process/dmx/ProcessInfoDmx.h	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/IPlayer.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+
+namespace VIDEOPLAYER
+{
+class CProcessInfoDmx : public CProcessInfo
+{
+public:
+  static CProcessInfo* Create();
+  static void Register();
+
+  CProcessInfoDmx();
+  EINTERLACEMETHOD GetFallbackDeintMethod() override;
+  std::vector<AVPixelFormat> GetRenderFormats() override;
+};
+} // namespace VIDEOPLAYER
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -47,6 +47,7 @@
                        "ios" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "tvos" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "gbm" IN_LIST CORE_PLATFORM_NAME_LC OR
+                       "dmx" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "x11" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "wayland" IN_LIST CORE_PLATFORM_NAME_LC))
   list(APPEND SOURCES LinuxRendererGLES.cpp
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -62,6 +62,11 @@
   endif()
 endif()
 
+if(MMAL_FOUND)
+  list(APPEND SOURCES RendererMMAL.cpp)
+  list(APPEND HEADERS RendererMMAL.h)
+endif()
+
 # we might want to build on linux systems
 # with ENABLE_VDPAU=OFF and ENABLE_VAAPI=OFF
 if(SOURCES)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.cpp	2023-04-10 16:35:35.668877516 +0000
@@ -0,0 +1,717 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RendererMMAL.h"
+
+#include "ServiceBroker.h"
+#include "cores/VideoPlayer/Buffers/VideoBufferPoolMMAL.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
+#include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/vc/mmal_vc_msgs.h>
+
+using namespace MMAL;
+using namespace std::chrono_literals;
+
+#define MMAL_COMPONENT_DEFAULT_ISP_CONVERTER "vc.ril.isp"
+
+const std::string SETTING_VIDEOPLAYER_USEMMALRENDERER = "videoplayer.usemmaldecoderforhw";
+
+CBaseRenderer* CRendererMMAL::Create(CVideoBuffer* buffer)
+{
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+          SETTING_VIDEOPLAYER_USEMMALRENDERER) &&
+      buffer)
+  {
+    auto buf = dynamic_cast<CVideoBufferMMAL*>(buffer);
+
+    if (buf)
+    {
+      auto winSystem =
+          static_cast<KODI::WINDOWING::DMX::CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+      if (winSystem)
+        return new CRendererMMAL(winSystem);
+    }
+  }
+  return nullptr;
+}
+
+void CRendererMMAL::Register()
+{
+  auto winSystem =
+      dynamic_cast<KODI::WINDOWING::DMX::CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+  if (winSystem)
+  {
+    CServiceBroker::GetSettingsComponent()
+        ->GetSettings()
+        ->GetSetting(SETTING_VIDEOPLAYER_USEMMALRENDERER)
+        ->SetVisible(true);
+    VIDEOPLAYER::CRendererFactory::RegisterRenderer("mmal", CRendererMMAL::Create);
+    return;
+  }
+}
+
+void CRendererMMAL::ProcessControlCallback(MMALPort port, MMALBufferHeader header)
+{
+  CRendererMMAL* renderer = static_cast<CRendererMMAL*>((void*)port->userdata);
+  if (renderer && header->cmd == MMAL_EVENT_ERROR)
+  {
+    MMALStatus status = *(MMALStatus*)header->data;
+    if (status != MMAL_EAGAIN)
+    {
+      renderer->m_state = MRS_ERROR;
+      CLog::Log(LOGWARNING, "CRendererMMAL::{} - renderer error reported: {}", __FUNCTION__,
+                mmal_status_to_string(status));
+    }
+  }
+  mmal_buffer_header_release(header);
+}
+
+void CRendererMMAL::ProcessInputCallback(MMALPort port, MMALBufferHeader header)
+{
+  CRendererMMAL* renderer = static_cast<CRendererMMAL*>((void*)port->userdata);
+  if (renderer)
+  {
+    CVideoBufferMMAL* buffer = static_cast<CVideoBufferMMAL*>(header->user_data);
+    if (buffer)
+    {
+      std::unique_lock<CCriticalSection> lock(renderer->m_bufferLock);
+      buffer->SetRenderIndex(-1);
+      lock.unlock();
+      renderer->m_bufferCondition.notify();
+    }
+    else
+      mmal_buffer_header_release(header);
+  }
+  else
+    mmal_buffer_header_release(header);
+}
+
+CRendererMMAL::CRendererMMAL(KODI::WINDOWING::DMX::CWinSystemDmx* winSystem)
+  : CBaseRenderer::CBaseRenderer(), m_winSystem(winSystem)
+{
+  MMALStatus status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &m_renderer);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to create renderer component", __FUNCTION__);
+    return;
+  }
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_ISP_CONVERTER, &m_isp);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to create renderer component", __FUNCTION__);
+    return;
+  }
+  if (m_renderer->is_enabled != 0)
+    mmal_component_disable(m_renderer);
+  if (m_isp->is_enabled != 0)
+    mmal_component_disable(m_isp);
+
+  *(int*)((uint8_t*)m_renderer->priv + 28) = VCOS_THREAD_PRI_REALTIME;
+  *(int*)((uint8_t*)m_isp->priv + 28) = VCOS_THREAD_PRI_ABOVE_NORMAL;
+
+  m_bufferCount = MMAL_RENDERER_NUM_BUFFERS - 2;
+  m_port = m_renderer->input[0];
+  m_port->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+  m_port->buffer_num = m_bufferCount;
+  m_port->buffer_num_min = 2;
+  m_port->buffer_num_recommended = m_bufferCount;
+  m_portFormat = mmal_format_alloc();
+  m_portFormat->extradata = nullptr;
+  m_portFormat->extradata_size = 0;
+  m_format = AV_PIX_FMT_NONE;
+
+  for (int i = 0; i < MMAL_RENDERER_NUM_BUFFERS; i++)
+    m_buffers[i] = nullptr;
+
+  mmal_port_parameter_set_uint32(m_port, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+  mmal_port_parameter_set_boolean(m_port, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+
+  MMAL_PARAMETER_HEADER_T* parameter =
+      mmal_port_parameter_alloc_get(m_port, MMAL_PARAMETER_SUPPORTED_ENCODINGS, 0, &status);
+  if (status == MMAL_SUCCESS)
+  {
+    uint32_t* formats = (uint32_t*)((uint8_t*)parameter + sizeof(*parameter));
+    for (uint32_t i = 0; i < 24; i++)
+    {
+      if (i < (parameter->size - sizeof(*parameter)) / 4)
+        m_renderFormats[i] = formats[i];
+      else
+        m_renderFormats[i] = MMAL_ENCODING_UNKNOWN;
+    }
+    mmal_port_parameter_free(parameter);
+  }
+  m_renderer->control->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+  status = mmal_port_enable(m_renderer->control, CRendererMMAL::ProcessControlCallback);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to enable renderer control port", __FUNCTION__);
+    return;
+  }
+  MMALPort ispPort = m_isp->input[0];
+  ispPort->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+  ispPort->buffer_num = m_bufferCount;
+  ispPort->buffer_num_min = 2;
+  ispPort->buffer_num_recommended = m_bufferCount;
+
+  mmal_port_parameter_set_uint32(ispPort, MMAL_PARAMETER_EXTRA_BUFFERS, 0);
+  mmal_port_parameter_set_boolean(ispPort, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE);
+
+  parameter =
+      mmal_port_parameter_alloc_get(ispPort, MMAL_PARAMETER_SUPPORTED_ENCODINGS, 0, &status);
+  if (status == MMAL_SUCCESS)
+  {
+    uint32_t* formats = (uint32_t*)((uint8_t*)parameter + sizeof(*parameter));
+    for (uint32_t i = 0; i < 64; i++)
+    {
+      if (i < (parameter->size - sizeof(*parameter)) / 4)
+        m_ispFormats[i] = formats[i];
+      else
+        m_ispFormats[i] = MMAL_ENCODING_UNKNOWN;
+    }
+    mmal_port_parameter_free(parameter);
+  }
+  m_isp->control->userdata = (struct MMAL_PORT_USERDATA_T*)this;
+  status = mmal_port_enable(m_isp->control, CRendererMMAL::ProcessControlCallback);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to enable isp control port", __FUNCTION__);
+    return;
+  }
+  m_state = MRS_INITIALIZED;
+}
+
+CRendererMMAL::~CRendererMMAL()
+{
+  MMALRendererState state = m_state;
+  Flush(false);
+  m_state = MRS_DESTROYING;
+
+  if (m_renderer->control->is_enabled != 0)
+  {
+    if (mmal_port_disable(m_renderer->control) == MMAL_SUCCESS)
+      m_renderer->control->userdata = nullptr;
+    else
+      CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to disable renderer control port",
+                __FUNCTION__);
+  }
+
+  if (m_isp->control->is_enabled != 0)
+  {
+    if (mmal_port_disable(m_isp->control) == MMAL_SUCCESS)
+      m_isp->control->userdata = nullptr;
+    else
+      CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to disable isp control port", __FUNCTION__);
+  }
+
+  if (m_connection)
+  {
+    mmal_connection_destroy(m_connection);
+    m_connection = nullptr;
+  }
+
+  if (m_renderer->is_enabled != 0)
+    mmal_component_disable(m_renderer);
+
+  if (m_isp->is_enabled != 0)
+    mmal_component_disable(m_isp);
+
+  m_port->userdata = nullptr;
+
+  if (m_portFormat)
+  {
+    mmal_format_free(m_portFormat);
+    m_portFormat = nullptr;
+  }
+
+  if (mmal_component_release(m_renderer) != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to release renderer component", __FUNCTION__);
+  if (mmal_component_release(m_isp) != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to release isp component", __FUNCTION__);
+
+  m_renderer = nullptr;
+  m_isp = nullptr;
+
+  m_state = MRS_UNINITIALIZED;
+}
+
+bool CRendererMMAL::Configure(const VideoPicture& picture, float fps, unsigned int orientation)
+{
+  CVideoBufferMMAL* buffer = nullptr;
+
+  if ((buffer = dynamic_cast<CVideoBufferMMAL*>(picture.videoBuffer)) != NULL)
+  {
+    MMALFormat format = buffer->GetPortFormat();
+    uint32_t inputFormat = MMAL_ENCODING_UNKNOWN;
+    uint32_t outputFormat = MMAL_ENCODING_UNKNOWN;
+
+    for (int i = 0; i < 24; i++)
+    {
+      if (m_renderFormats[i] == MMAL_ENCODING_UNKNOWN)
+        break;
+      else if (format->encoding == m_renderFormats[i])
+      {
+        inputFormat = m_renderFormats[i];
+        break;
+      }
+    }
+    if (inputFormat == MMAL_ENCODING_UNKNOWN)
+    {
+      for (int i = 0; i < 64; i++)
+      {
+        if (m_ispFormats[i] == MMAL_ENCODING_UNKNOWN)
+          break;
+        else if (format->encoding == m_ispFormats[i])
+        {
+          inputFormat = m_ispFormats[i];
+          break;
+        }
+      }
+      if (inputFormat == MMAL_ENCODING_YUVUV64_10 || inputFormat == MMAL_ENCODING_YUVUV64_16)
+        outputFormat = MMAL_ENCODING_YUVUV128;
+      else
+        outputFormat = MMAL_ENCODING_I420;
+    }
+    else
+    {
+      outputFormat = inputFormat;
+    }
+
+    if (inputFormat == MMAL_ENCODING_UNKNOWN || outputFormat == MMAL_ENCODING_UNKNOWN)
+    {
+      //unsupported format
+      return false;
+    }
+    if (mmal_format_compare(m_portFormat, format) != 0)
+    {
+      if (inputFormat == outputFormat)
+        m_port = m_renderer->input[0];
+      else
+        m_port = m_isp->input[0];
+      if (mmal_format_full_copy(m_portFormat, format) == MMAL_SUCCESS)
+      {
+        std::unique_lock<CCriticalSection> lock(m_portLock);
+        mmal_format_copy(m_port->format, m_portFormat);
+        if (inputFormat != outputFormat)
+          m_port->format->es->video.color_space = MMAL_COLOR_SPACE_UNKNOWN;
+        if (mmal_port_format_commit(m_port) != MMAL_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to commit port format", __FUNCTION__);
+          return false;
+        }
+      }
+      else
+      {
+        CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to copy port format", __FUNCTION__);
+        return false;
+      }
+
+      m_port->buffer_size = buffer->GetSize();
+      m_port->buffer_num = m_bufferCount;
+
+      if (inputFormat != outputFormat)
+      {
+        if (mmal_format_full_copy(m_isp->output[0]->format, m_portFormat) == MMAL_SUCCESS)
+        {
+          m_isp->output[0]->format->encoding = outputFormat;
+          m_isp->output[0]->format->encoding_variant = MMAL_ENCODING_UNKNOWN;
+          m_isp->output[0]->format->es->video.color_space = m_portFormat->es->video.color_space;
+          if (outputFormat == MMAL_ENCODING_YUVUV128)
+          {
+            m_isp->output[0]->format->es->video.width =
+                VCOS_ALIGN_UP(m_isp->output[0]->format->es->video.crop.width, 32);
+            m_isp->output[0]->format->es->video.height =
+                VCOS_ALIGN_UP(m_isp->output[0]->format->es->video.crop.height, 16);
+            if ((m_isp->output[0]->format->flags &
+                 MMAL_ES_FORMAT_FLAG_COL_FMTS_WIDTH_IS_COL_STRIDE) != 0)
+              m_isp->output[0]->format->flags &= ~MMAL_ES_FORMAT_FLAG_COL_FMTS_WIDTH_IS_COL_STRIDE;
+          }
+
+          if (mmal_port_format_commit(m_isp->output[0]) != MMAL_SUCCESS)
+          {
+            CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to commit isp port format",
+                      __FUNCTION__);
+            return false;
+          }
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to copy isp port format", __FUNCTION__);
+          return false;
+        }
+        m_isp->output[0]->buffer_size = m_isp->output[0]->buffer_size_recommended;
+        m_isp->output[0]->buffer_num = m_bufferCount;
+        if (mmal_connection_create(&m_connection, m_isp->output[0], m_renderer->input[0],
+                                   MMAL_CONNECTION_FLAG_TUNNELLING) != MMAL_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to create isp connection", __FUNCTION__);
+          return false;
+        }
+      }
+    }
+
+    m_fps = fps;
+    m_format = picture.videoBuffer->GetFormat();
+    m_sourceWidth = picture.iWidth;
+    m_sourceHeight = picture.iHeight;
+    m_renderOrientation = orientation;
+
+    m_iFlags = GetFlagsChromaPosition(picture.chroma_position) |
+               GetFlagsColorMatrix(picture.color_space, picture.iWidth, picture.iHeight) |
+               GetFlagsColorPrimaries(picture.color_primaries) |
+               GetFlagsStereoMode(picture.stereoMode);
+
+    CalculateFrameAspectRatio(picture.iDisplayWidth, picture.iDisplayHeight);
+    SetViewMode(m_videoSettings.m_ViewMode);
+
+    CDisplaySettings::GetInstance().SetPixelRatio(1.0);
+
+    m_displayRegion.hdr.id = MMAL_PARAMETER_DISPLAYREGION;
+    m_displayRegion.hdr.size = sizeof(MMAL_DISPLAYREGION_T);
+
+    m_displayRegion.set = MMAL_DISPLAY_SET_LAYER;
+    m_displayRegion.layer = 0;
+
+    m_displayRegion.set |= MMAL_DISPLAY_SET_NUM;
+    m_displayRegion.display_num = 2;
+
+    m_displayRegion.set |= MMAL_DISPLAY_SET_ALPHA;
+    m_displayRegion.alpha = 255 | MMAL_DISPLAY_ALPHA_FLAGS_DISCARD_LOWER_LAYERS;
+
+    m_displayRegion.set |= MMAL_DISPLAY_SET_FULLSCREEN;
+    m_displayRegion.fullscreen = MMAL_FALSE;
+
+    m_displayRegion.set |= MMAL_DISPLAY_SET_NOASPECT;
+    m_displayRegion.noaspect = MMAL_TRUE;
+
+    m_displayRegion.set |= MMAL_DISPLAY_SET_MODE;
+    m_displayRegion.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+
+    m_displayRegion.transform = MMAL_DISPLAY_DUMMY;
+
+    m_state = MRS_CONFIGURED;
+
+    ManageRenderArea();
+
+    return true;
+  }
+}
+
+void CRendererMMAL::ManageRenderArea()
+{
+  CBaseRenderer::ManageRenderArea();
+
+  if (m_state == MRS_CONFIGURED || m_state == MRS_RENDERING)
+  {
+    MMAL_DISPLAYTRANSFORM_T transform = MMAL_DISPLAY_ROT0;
+
+    if (m_renderOrientation > 0)
+    {
+      switch (m_renderOrientation)
+      {
+        case 270:
+          transform = MMAL_DISPLAY_ROT90;
+          break;
+        case 180:
+          transform = MMAL_DISPLAY_ROT180;
+          break;
+        case 90:
+          transform = MMAL_DISPLAY_ROT270;
+          break;
+        default:
+          transform = MMAL_DISPLAY_ROT0;
+          break;
+      }
+    }
+
+    if (m_displayRegion.transform != transform)
+    {
+      m_displayRegion.set |= MMAL_DISPLAY_SET_TRANSFORM;
+      m_displayRegion.transform = transform;
+    }
+
+    if (m_displayRegion.src_rect.x != (int32_t)m_sourceRect.x1 ||
+        m_displayRegion.src_rect.y != (int32_t)m_sourceRect.y1 ||
+        m_displayRegion.src_rect.width != (int32_t)m_sourceRect.Width() ||
+        m_displayRegion.src_rect.height != (int32_t)m_sourceRect.Height())
+    {
+      m_displayRegion.set |= MMAL_DISPLAY_SET_SRC_RECT;
+      m_displayRegion.src_rect.x = m_sourceRect.x1;
+      m_displayRegion.src_rect.y = m_sourceRect.y1;
+      m_displayRegion.src_rect.width = m_sourceRect.Width();
+      m_displayRegion.src_rect.height = m_sourceRect.Height();
+    }
+
+    if (m_displayRegion.dest_rect.x != (int32_t)m_destRect.x1 ||
+        m_displayRegion.dest_rect.y != (int32_t)m_destRect.y1 ||
+        m_displayRegion.dest_rect.width != (int32_t)m_destRect.Width() ||
+        m_displayRegion.dest_rect.height != (int32_t)m_destRect.Height())
+    {
+      m_displayRegion.set |= MMAL_DISPLAY_SET_DEST_RECT;
+      m_displayRegion.dest_rect.x = m_destRect.x1;
+      m_displayRegion.dest_rect.y = m_destRect.y1;
+      m_displayRegion.dest_rect.width = m_destRect.Width();
+      m_displayRegion.dest_rect.height = m_destRect.Height();
+    }
+
+    if (m_displayRegion.set != MMAL_DISPLAY_SET_NONE)
+    {
+      // aspect is calculated by CBaseRenderer?
+      m_displayRegion.set |= MMAL_DISPLAY_SET_PIXEL;
+      m_displayRegion.pixel_x = 1;
+      m_displayRegion.pixel_y = 1;
+
+      std::unique_lock<CCriticalSection> lock(m_portLock);
+      if (mmal_port_parameter_set(m_port, &m_displayRegion.hdr) == MMAL_SUCCESS)
+        m_displayRegion.set = MMAL_DISPLAY_SET_NONE;
+      else
+        CLog::Log(LOGWARNING, "CRendererMMAL::{} - failed to configure display region",
+                  __FUNCTION__);
+    }
+  }
+}
+
+bool CRendererMMAL::IsConfigured()
+{
+  return m_state != MRS_INITIALIZED && m_state != MRS_UNINITIALIZED && m_state != MRS_DESTROYING;
+}
+
+void CRendererMMAL::AddVideoPicture(const VideoPicture& picture, int index)
+{
+  CVideoBufferMMAL* buffer = nullptr;
+  if ((buffer = dynamic_cast<CVideoBufferMMAL*>(picture.videoBuffer)) != NULL)
+  {
+    MMALBufferHeader header = buffer->GetHeader();
+
+    AcquireBuffer(buffer, index);
+  }
+}
+
+void CRendererMMAL::Update()
+{
+  if (m_state == MRS_RENDERING)
+    ManageRenderArea();
+}
+
+void CRendererMMAL::RenderUpdate(
+    int index, int index2, bool clear, unsigned int flags, unsigned int alpha)
+{
+  MMALRendererState state = m_state;
+
+  if (state == MRS_RENDERING)
+  {
+    if (!SendBuffer(index))
+      ReleaseBuffer(index);
+  }
+  else if (state == MRS_CONFIGURED || state == MRS_FLUSHED)
+  {
+    ManageRenderArea();
+    if (m_port->is_enabled == 0)
+    {
+      m_port->buffer_num = m_bufferCount;
+      std::unique_lock<CCriticalSection> lock(m_portLock);
+      if (mmal_port_enable(m_port, CRendererMMAL::ProcessInputCallback) == MMAL_SUCCESS)
+      {
+        if (m_connection)
+        {
+          mmal_connection_enable(m_connection);
+
+          if (m_isp->is_enabled == 0)
+            mmal_component_enable(m_isp);
+        }
+        if (m_renderer->is_enabled == 0)
+          mmal_component_enable(m_renderer);
+      }
+    }
+    if (!SendBuffer(index))
+      ReleaseBuffer(index);
+    else
+      m_state = MRS_RENDERING;
+  }
+}
+
+bool CRendererMMAL::Flush(bool saveBuffers)
+{
+  MMALRendererState state = m_state;
+  m_state = MRS_FLUSHING;
+  if (state == MRS_RENDERING)
+  {
+    if (!saveBuffers)
+    {
+      std::unique_lock<CCriticalSection> lock(m_bufferLock);
+      bool flush = false;
+      for (int i = 0; i < MMAL_RENDERER_NUM_BUFFERS; i++)
+      {
+        if (m_buffers[i] != nullptr)
+        {
+          if (m_buffers[i]->GetRenderIndex() == -1)
+          {
+            m_buffers[i]->Release();
+            m_buffers[i] = nullptr;
+          }
+          else
+            flush = true;
+        }
+      }
+      if (flush && m_port->is_enabled != 0)
+      {
+        std::unique_lock<CCriticalSection> plock(m_portLock);
+        if (mmal_port_disable(m_port) != MMAL_SUCCESS)
+          CLog::Log(LOGERROR, "CRendererMMAL::{} - failed to flush input port", __FUNCTION__);
+        for (int i = 0; i < MMAL_RENDERER_NUM_BUFFERS; i++)
+        {
+          if (m_buffers[i] != nullptr)
+          {
+            m_buffers[i]->Release();
+            m_buffers[i] = nullptr;
+          }
+        }
+      }
+    }
+  }
+  m_state = MRS_FLUSHED;
+
+  return saveBuffers;
+}
+
+bool CRendererMMAL::SendBuffer(int index)
+{
+  std::unique_lock<CCriticalSection> lock(m_bufferLock);
+  if (m_buffers[index] != nullptr)
+  {
+    if (m_buffers[index]->GetRenderIndex() == index)
+      return true;
+
+    MMALBufferHeader header = m_buffers[index]->GetHeader();
+    if ((header->flags & MMAL_BUFFER_HEADER_FLAG_DROPPED) == 0)
+    {
+      m_buffers[index]->SetRenderIndex(index);
+      if (m_state == MRS_FLUSHED && (header->flags & MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY) == 0)
+        header->flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
+      MMALStatus status = mmal_port_send_buffer(m_port, header);
+      if (status == MMAL_EAGAIN)
+      {
+        m_winSystem->WaitVerticalSync(m_winSystem->WaitVerticalSync(0) + 1, 1000 / m_fps);
+        status = mmal_port_send_buffer(m_port, header);
+      }
+      if (status == MMAL_SUCCESS)
+      {
+        if (m_state == MRS_RENDERING)
+          m_bufferCondition.wait(lock);
+        return true;
+      }
+      m_buffers[index]->SetRenderIndex(-1);
+    }
+  }
+  return false;
+}
+
+void CRendererMMAL::AcquireBuffer(CVideoBufferMMAL* buffer, int index)
+{
+  std::unique_lock<CCriticalSection> lock(m_bufferLock);
+  if (m_buffers[index] != nullptr)
+  {
+    m_buffers[index]->Release();
+    m_buffers[index] = nullptr;
+  }
+  buffer->Acquire(false);
+  m_buffers[index] = buffer;
+  m_buffers[index]->SetRenderIndex(-1);
+}
+
+void CRendererMMAL::ReleaseBuffer(int index)
+{
+  std::unique_lock<CCriticalSection> lock(m_bufferLock);
+  if (m_buffers[index] != nullptr)
+  {
+    m_buffers[index]->Release();
+    m_buffers[index] = nullptr;
+  }
+}
+
+bool CRendererMMAL::NeedBuffer(int index)
+{
+  std::unique_lock<CCriticalSection> lock(m_bufferLock);
+  bool result = false;
+  if (m_buffers[index] != nullptr)
+  {
+    if (m_buffers[index]->GetRenderIndex() != index)
+    {
+      m_buffers[index]->Release();
+      m_buffers[index] = nullptr;
+    }
+    else
+      result = true;
+  }
+  return result;
+}
+
+CRenderInfo CRendererMMAL::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.max_buffer_size = MMAL_RENDERER_NUM_BUFFERS;
+  info.optimal_buffer_size = m_port->buffer_num_recommended;
+
+  info.formats.push_back(AV_PIX_FMT_MMAL);
+  info.formats.push_back(AV_PIX_FMT_YUV420P);
+  info.formats.push_back(AV_PIX_FMT_YUVJ420P);
+  info.formats.push_back(AV_PIX_FMT_YUV420P10);
+  info.formats.push_back(AV_PIX_FMT_YUV420P12);
+  info.formats.push_back(AV_PIX_FMT_YUV420P14);
+  info.formats.push_back(AV_PIX_FMT_YUV420P16);
+  info.formats.push_back(AV_PIX_FMT_SAND128);
+  info.formats.push_back(AV_PIX_FMT_SAND64_10);
+  info.formats.push_back(AV_PIX_FMT_SAND64_16);
+  return info;
+}
+
+bool CRendererMMAL::ConfigChanged(const VideoPicture& picture)
+{
+  CVideoBufferMMAL* buffer = dynamic_cast<CVideoBufferMMAL*>(picture.videoBuffer);
+  if (buffer)
+    return mmal_format_compare(m_portFormat, buffer->GetPortFormat()) != 0;
+  return true;
+}
+
+void CRendererMMAL::SetBufferSize(int numBuffers)
+{
+  if (numBuffers > MMAL_RENDERER_NUM_BUFFERS)
+    m_bufferCount = MMAL_RENDERER_NUM_BUFFERS;
+  else
+    m_bufferCount = numBuffers;
+}
+
+bool CRendererMMAL::Supports(ERENDERFEATURE feature) const
+{
+  switch (feature)
+  {
+    case RENDERFEATURE_STRETCH:
+    case RENDERFEATURE_ZOOM:
+    case RENDERFEATURE_VERTICAL_SHIFT:
+    case RENDERFEATURE_PIXEL_RATIO:
+      return true;
+    default:
+      return false;
+  }
+}
+
+bool CRendererMMAL::Supports(ESCALINGMETHOD method) const
+{
+  return method == VS_SCALINGMETHOD_AUTO;
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.h xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.h	2023-04-09 16:32:02.209205202 +0000
@@ -0,0 +1,108 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/Buffers/VideoBufferMMAL.h"
+#include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+#include "windowing/dmx/WinSystemDmx.h"
+
+#include <atomic>
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/util/mmal_connection.h>
+
+#define MMAL_RENDERER_NUM_BUFFERS 6
+
+class CVideoBuffer;
+namespace MMAL
+{
+enum MMALRendererState
+{
+  MRS_UNINITIALIZED = 0, // 0
+  MRS_INITIALIZED, // 1 x
+  MRS_CONFIGURED, // 2 x
+  MRS_RENDERING, // 3
+  MRS_FLUSHING, // 4 x
+  MRS_FLUSHED, // 5 x
+  MRS_RESET,
+  MRS_DESTROYING,
+  MRS_ERROR, // 8
+};
+
+class CRendererMMAL : public CBaseRenderer
+{
+public:
+  CRendererMMAL(KODI::WINDOWING::DMX::CWinSystemDmx* winSystem);
+  ~CRendererMMAL() override;
+
+  // Registration
+  static CBaseRenderer* Create(CVideoBuffer* buffer);
+  static void Register();
+
+  // Player functions
+  bool Configure(const VideoPicture& picture, float fps, unsigned int orientation) override;
+  bool IsConfigured() override;
+  void AddVideoPicture(const VideoPicture& picture, int index) override;
+  void UnInit() override{};
+  bool Flush(bool saveBuffers) override;
+  void ReleaseBuffer(int idx) override;
+  bool NeedBuffer(int idx) override;
+  bool IsGuiLayer() override { return false; }
+  CRenderInfo GetRenderInfo() override;
+  void Update() override;
+  void RenderUpdate(
+      int index, int index2, bool clear, unsigned int flags, unsigned int alpha) override;
+  bool RenderCapture(CRenderCapture* capture) override { return true; };
+  bool ConfigChanged(const VideoPicture& picture) override;
+  void SetBufferSize(int numBuffers) override;
+
+  // Feature support
+  bool SupportsMultiPassRendering() override { return false; };
+  bool Supports(ERENDERFEATURE feature) const override;
+  bool Supports(ESCALINGMETHOD method) const override;
+
+protected:
+  void ManageRenderArea() override;
+
+private:
+  static void ProcessControlCallback(MMALPort port, MMALBufferHeader header);
+  static void ProcessInputCallback(MMALPort port, MMALBufferHeader header);
+
+  bool ConfigurePort(MMALFormat format, uint32_t bufferSize);
+
+  void AcquireBuffer(CVideoBufferMMAL* buffer, int index);
+  bool SendBuffer(int index);
+
+  std::atomic<MMALRendererState> m_state{MRS_UNINITIALIZED};
+
+  MMALComponent m_renderer{nullptr};
+  MMALPort m_port{nullptr};
+  MMALFormat m_portFormat{nullptr};
+  MMAL_CONNECTION_T* m_connection{nullptr};
+
+  MMALComponent m_isp{nullptr};
+
+  CVideoBufferMMAL* m_buffers[MMAL_RENDERER_NUM_BUFFERS];
+  uint32_t m_bufferCount{MMAL_RENDERER_NUM_BUFFERS};
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
+  MMAL_DISPLAYREGION_T m_displayRegion{NULL};
+#pragma GCC diagnostic pop
+
+  KODI::WINDOWING::DMX::CWinSystemDmx* m_winSystem{nullptr};
+
+  uint32_t m_renderFormats[24]{0};
+  uint32_t m_ispFormats[64]{0};
+
+  CCriticalSection m_portLock;
+  CCriticalSection m_bufferLock;
+  XbmcThreads::ConditionVariable m_bufferCondition;
+};
+} // namespace MMAL
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp	2023-04-01 23:53:53.000000000 +0000
@@ -28,6 +28,9 @@
 #include "utils/MathUtils.h"
 #include "utils/log.h"
 #include "windowing/WinSystem.h"
+#ifdef HAVE_DMX
+#include "windowing/dmx/WinSystemDmx.h"
+#endif
 
 #include <mutex>
 
@@ -1273,6 +1276,16 @@
   capture->BeginRender();
 
   Render(RENDER_FLAG_NOOSD, m_iYV12RenderBuffer);
+#if !defined(HAVE_DMX)
+  auto winSystem =
+      dynamic_cast<KODI::WINDOWING::DMX::CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+
+  if (winSystem)
+  {
+    winSystem->GetRenderPixels(0, CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight() - capture->GetHeight(),
+                               capture->GetWidth(), capture->GetHeight(), capture->GetRenderBuffer(), true, true, true);
+  }
+#else
   // read pixels
   glReadPixels(0, CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight() - capture->GetHeight(), capture->GetWidth(), capture->GetHeight(),
                GL_RGBA, GL_UNSIGNED_BYTE, capture->GetRenderBuffer());
@@ -1284,7 +1297,7 @@
   {
     std::swap(pixels[0], pixels[2]);
   }
-
+#endif
   capture->EndRender();
 
   // revert model view matrix
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -30,6 +30,7 @@
                        "ios" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "tvos" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "gbm" IN_LIST CORE_PLATFORM_NAME_LC OR
+                       "dmx" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "x11" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "wayland" IN_LIST CORE_PLATFORM_NAME_LC))
   list(APPEND SOURCES VideoFilterShaderGLES.cpp
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/VideoFilterShaderGLES.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -63,14 +63,17 @@
   std::string shadername;
   std::string defines;
 
+#if defined(GL_RGBA16F_EXT)
   if (CServiceBroker::GetRenderSystem()->IsExtSupported("GL_EXT_color_buffer_float"))
   {
     m_floattex = true;
   }
   else
+#else
   {
     m_floattex = false;
   }
+#endif
 
   if (m_method == VS_SCALINGMETHOD_CUBIC_B_SPLINE ||
       m_method == VS_SCALINGMETHOD_CUBIC_MITCHELL ||
@@ -88,17 +91,18 @@
   {
     shadername = "gles_convolution-6x6.frag";
   }
-
+#if defined(GL_RGBA16F_EXT)
   if (m_floattex)
   {
     m_internalformat = GL_RGBA16F_EXT;
     defines = "#define HAS_FLOAT_TEXTURE\n";
   }
   else
+#else
   {
     m_internalformat = GL_RGBA;
   }
-
+#endif
   CLog::Log(LOGDEBUG, "GLES: using scaling method: {}", m_method);
   CLog::Log(LOGDEBUG, "GLES: using shader: {}", shadername);
 
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/cores/VideoSettings.h xbmc-test-Nexus/xbmc/cores/VideoSettings.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoSettings.h	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/cores/VideoSettings.h	2023-03-29 12:12:33.000000000 +0000
@@ -36,6 +36,10 @@
   VS_INTERLACEMETHOD_VAAPI_BOB = 22,
   VS_INTERLACEMETHOD_VAAPI_MADI = 23,
   VS_INTERLACEMETHOD_VAAPI_MACI = 24,
+  VS_INTERLACEMETHOD_MMAL_ADVANCED = 25,
+  VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF = 26,
+  VS_INTERLACEMETHOD_MMAL_BOB = 27,
+  VS_INTERLACEMETHOD_MMAL_BOB_HALF = 28,
   VS_INTERLACEMETHOD_DXVA_AUTO = 32,
   VS_INTERLACEMETHOD_MAX // do not use and keep as last enum value.
 };
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/interfaces/python/XBPython.cpp xbmc-test-Nexus/xbmc/interfaces/python/XBPython.cpp
--- xbmc-20.1-Nexus/xbmc/interfaces/python/XBPython.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/interfaces/python/XBPython.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -17,6 +17,7 @@
 #include "ServiceBroker.h"
 #include "Util.h"
 #include "cores/DllLoader/DllLoaderContainer.h"
+#include "filesystem/File.h"
 #include "filesystem/SpecialProtocol.h"
 #include "interfaces/AnnouncementManager.h"
 #include "interfaces/legacy/AddonUtils.h"
@@ -518,6 +519,12 @@
     Py_OptimizeFlag = 1;
 #endif
 
+#if !defined(TARGET_WINDOWS)
+    // use Kodi provided cert if available
+    if (XFILE::CFile::Exists("special://xbmc/system/certs/cacert.pem"))
+      setenv("SSL_CERT_FILE", CSpecialProtocol::TranslatePath("special://xbmc/system/certs/cacert.pem").c_str(), 1);
+#endif
+
     Py_Initialize();
 
 #if PY_VERSION_HEX < 0x03070000
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/platform/linux/CPUInfoLinux.cpp xbmc-test-Nexus/xbmc/platform/linux/CPUInfoLinux.cpp
--- xbmc-20.1-Nexus/xbmc/platform/linux/CPUInfoLinux.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/platform/linux/CPUInfoLinux.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -94,7 +94,8 @@
   if (freqPath.Exists())
     m_freqPath = freqStr;
 
-  const std::array<std::string, 4> modules = {
+  const std::array<std::string, 5> modules = {
+      "cpu_thermal",
       "coretemp",
       "k10temp",
       "scpi_sensors",
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/platform/linux/input/CMakeLists.txt xbmc-test-Nexus/xbmc/platform/linux/input/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/platform/linux/input/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/platform/linux/input/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -6,7 +6,7 @@
   list(APPEND HEADERS LIRC.h)
 endif()
 
-if("gbm" IN_LIST CORE_PLATFORM_NAME_LC)
+if("dmx" IN_LIST CORE_PLATFORM_NAME_LC OR "gbm" IN_LIST CORE_PLATFORM_NAME_LC)
   if(LIBINPUT_FOUND)
     list(APPEND SOURCES LibInputHandler.cpp
                         LibInputKeyboard.cpp
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/platform/linux/PlatformLinux.cpp xbmc-test-Nexus/xbmc/platform/linux/PlatformLinux.cpp
--- xbmc-20.1-Nexus/xbmc/platform/linux/PlatformLinux.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/platform/linux/PlatformLinux.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -32,6 +32,9 @@
 #if defined(HAVE_GBM)
 #include "windowing/gbm/WinSystemGbmGLESContext.h"
 #endif
+#if defined(HAVE_DMX)
+#include "windowing/dmx/WinSystemDmxGLESContext.h"
+#endif
 #endif
 
 #if defined(HAS_GL)
@@ -71,6 +74,9 @@
 #if defined(HAVE_GBM)
   KODI::WINDOWING::GBM::CWinSystemGbmGLESContext::Register();
 #endif
+#if defined(HAVE_DMX)
+  KODI::WINDOWING::DMX::CWinSystemDmxGLESContext::Register();
+#endif
 #endif
 
 #if defined(HAS_GL)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/rendering/gles/ScreenshotSurfaceGLES.cpp xbmc-test-Nexus/xbmc/rendering/gles/ScreenshotSurfaceGLES.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/gles/ScreenshotSurfaceGLES.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/rendering/gles/ScreenshotSurfaceGLES.cpp	2023-04-06 15:13:40.578031188 +0000
@@ -13,6 +13,9 @@
 #include "guilib/GUIWindowManager.h"
 #include "utils/Screenshot.h"
 #include "windowing/GraphicContext.h"
+#ifdef HAVE_DMX
+#include "windowing/dmx/WinSystemDmx.h"
+#endif
 
 #include <mutex>
 #include <vector>
@@ -50,7 +53,17 @@
   m_height = viewport[3] - viewport[1];
   m_stride = m_width * 4;
   std::vector<uint8_t> surface(m_stride * m_height);
+#if defined(HAVE_DMX)
+  auto winsystemDmx = dynamic_cast<KODI::WINDOWING::DMX::CWinSystemDmx*>(winsystem);
 
+  if (winsystemDmx)
+  {
+    winsystemDmx->ReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_RGBA, true, surface.data());
+    m_buffer = new unsigned char[m_stride * m_height];
+    for (int y = 0; y < m_height; y++)
+      memcpy(m_buffer + y * m_stride, surface.data() + y * m_stride, m_stride);
+  }
+#else
   //read pixels from the backbuffer
   glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_RGBA, GL_UNSIGNED_BYTE, static_cast<GLvoid*>(surface.data()));
 
@@ -67,6 +80,6 @@
 
     memcpy(m_buffer + y * m_stride, surface.data() + (m_height - y - 1) * m_stride, m_stride);
   }
-
+#endif
   return m_buffer != nullptr;
 }
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/settings/SettingConditions.cpp xbmc-test-Nexus/xbmc/settings/SettingConditions.cpp
--- xbmc-20.1-Nexus/xbmc/settings/SettingConditions.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/settings/SettingConditions.cpp	2023-04-06 14:30:27.216385496 +0000
@@ -390,6 +390,9 @@
 #ifdef HAVE_LIBVDPAU
   m_simpleConditions.emplace("have_libvdpau");
 #endif
+#ifdef HAVE_MMAL
+  m_simpleConditions.emplace("have_mmal");
+#endif
 #ifdef TARGET_ANDROID
   m_simpleConditions.emplace("has_mediacodec");
 #endif
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/settings/Settings.cpp xbmc-test-Nexus/xbmc/settings/Settings.cpp
--- xbmc-20.1-Nexus/xbmc/settings/Settings.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/settings/Settings.cpp	2023-03-29 12:12:33.000000000 +0000
@@ -150,6 +150,7 @@
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEDXVA2;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEVTB;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEMMALDECODER;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USESTAGEFRIGHT;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC;
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/settings/Settings.h xbmc-test-Nexus/xbmc/settings/Settings.h
--- xbmc-20.1-Nexus/xbmc/settings/Settings.h	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/settings/Settings.h	2023-03-29 12:12:33.000000000 +0000
@@ -125,6 +125,7 @@
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAUVC1 = "videoplayer.usevdpauvc1";
   static constexpr auto SETTING_VIDEOPLAYER_USEDXVA2 = "videoplayer.usedxva2";
   static constexpr auto SETTING_VIDEOPLAYER_USEVTB = "videoplayer.usevtb";
+  static constexpr auto SETTING_VIDEOPLAYER_USEMMALDECODER = "videoplayer.usemmaldecoder";
   static constexpr auto SETTING_VIDEOPLAYER_USEPRIMEDECODER = "videoplayer.useprimedecoder";
   static constexpr auto SETTING_VIDEOPLAYER_USESTAGEFRIGHT = "videoplayer.usestagefright";
   static constexpr auto SETTING_VIDEOPLAYER_LIMITGUIUPDATE = "videoplayer.limitguiupdate";
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/utils/CMakeLists.txt xbmc-test-Nexus/xbmc/utils/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/utils/CMakeLists.txt	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/utils/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -202,17 +202,19 @@
   list(APPEND HEADERS GLUtils.h)
 endif()
 
-if("gbm" IN_LIST CORE_PLATFORM_NAME_LC OR "wayland" IN_LIST CORE_PLATFORM_NAME_LC)
+if("gbm" IN_LIST CORE_PLATFORM_NAME_LC OR "dmx" IN_LIST CORE_PLATFORM_NAME_LC OR "wayland" IN_LIST CORE_PLATFORM_NAME_LC)
   list(APPEND SOURCES BufferObject.cpp
                       BufferObjectFactory.cpp)
   list(APPEND HEADERS BufferObject.h
                       BufferObjectFactory.h)
+endif()
 
-  if("gbm" IN_LIST CORE_PLATFORM_NAME_LC)
-    list(APPEND SOURCES DumbBufferObject.cpp)
-    list(APPEND SOURCES DumbBufferObject.h)
-  endif()
+if("gbm" IN_LIST CORE_PLATFORM_NAME_LC)
+  list(APPEND SOURCES DumbBufferObject.cpp)
+  list(APPEND SOURCES DumbBufferObject.h)
+endif()
 
+if("gbm" IN_LIST CORE_PLATFORM_NAME_LC OR "wayland" IN_LIST CORE_PLATFORM_NAME_LC)
   if(HAVE_LINUX_MEMFD AND HAVE_LINUX_UDMABUF)
     list(APPEND SOURCES UDMABufferObject.cpp)
     list(APPEND HEADERS UDMABufferObject.h)
@@ -227,7 +229,9 @@
     list(APPEND SOURCES GBMBufferObject.cpp)
     list(APPEND HEADERS GBMBufferObject.h)
   endif()
+endif()
 
+if("gbm" IN_LIST CORE_PLATFORM_NAME_LC OR "wayland" IN_LIST CORE_PLATFORM_NAME_LC)
   if(EGL_FOUND)
     list(APPEND SOURCES EGLImage.cpp)
     list(APPEND HEADERS EGLImage.h)
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/utils/EGLUtils.cpp xbmc-test-Nexus/xbmc/utils/EGLUtils.cpp
--- xbmc-20.1-Nexus/xbmc/utils/EGLUtils.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/utils/EGLUtils.cpp	2023-04-06 12:41:27.000000000 +0000
@@ -21,6 +21,24 @@
 
 namespace
 {
+#ifndef EGL_NO_CONFIG_KHR
+#define EGL_NO_CONFIG_KHR static_cast<EGLConfig>(0)
+#endif
+#ifndef EGL_CONTEXT_PRIORITY_LEVEL_IMG
+#define EGL_CONTEXT_PRIORITY_LEVEL_IMG 0x3100
+#endif
+#ifndef EGL_CONTEXT_PRIORITY_HIGH_IMG
+#define EGL_CONTEXT_PRIORITY_HIGH_IMG 0x3101
+#endif
+#ifndef EGL_CONTEXT_PRIORITY_MEDIUM_IMG
+#define EGL_CONTEXT_PRIORITY_MEDIUM_IMG 0x3102
+#endif
+#ifndef EGL_CONTEXT_FLAGS_KHR
+#define EGL_CONTEXT_FLAGS_KHR 0x30FC
+#endif
+#ifndef EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR
+#define EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR 0x00000001
+#endif
 
 #define X(VAL) std::make_pair(VAL, #VAL)
 std::map<EGLint, const char*> eglAttributes =
@@ -82,6 +100,7 @@
   X(EGL_CONTEXT_LOST),
 };
 
+#if defined(GL_KHR_debug)
 std::map<EGLint, const char*> eglErrorType =
 {
   X(EGL_DEBUG_MSG_CRITICAL_KHR),
@@ -89,10 +108,12 @@
   X(EGL_DEBUG_MSG_WARN_KHR),
   X(EGL_DEBUG_MSG_INFO_KHR),
 };
+#endif
 #undef X
 
 } // namespace
 
+#if defined(GL_KHR_debug)
 void EglErrorCallback(EGLenum error,
                       const char* command,
                       EGLint messageType,
@@ -117,6 +138,7 @@
 
   CLog::Log(LOGDEBUG, "EGL Debugging:\nError: {}\nCommand: {}\nType: {}\nMessage: {}", errorStr, command, typeStr, message);
 }
+#endif
 
 std::set<std::string> CEGLUtils::GetClientExtensions()
 {
@@ -171,6 +193,7 @@
 CEGLContextUtils::CEGLContextUtils(EGLenum platform, std::string const& platformExtension)
 : m_platform{platform}
 {
+#if defined(GL_KHR_debug)
   if (CEGLUtils::HasClientExtension("EGL_KHR_debug"))
   {
     auto eglDebugMessageControl = CEGLUtils::GetRequiredProcAddress<PFNEGLDEBUGMESSAGECONTROLKHRPROC>("eglDebugMessageControlKHR");
@@ -183,6 +206,7 @@
 
     eglDebugMessageControl(EglErrorCallback, eglDebugAttribs);
   }
+#endif
 
   m_platformSupported = CEGLUtils::HasClientExtension("EGL_EXT_platform_base") && CEGLUtils::HasClientExtension(platformExtension);
 }
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/utils/GLUtils.cpp xbmc-test-Nexus/xbmc/utils/GLUtils.cpp
--- xbmc-20.1-Nexus/xbmc/utils/GLUtils.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/utils/GLUtils.cpp	2023-03-29 16:19:39.000000000 +0000
@@ -40,8 +40,9 @@
 #endif
 };
 
-std::map<GLenum, const char*> glErrorSource = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
+std::map<GLenum, const char*> glErrorSource =
+{
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && defined(GL_KHR_debug)
     X(GL_DEBUG_SOURCE_API_KHR),
     X(GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR),
     X(GL_DEBUG_SOURCE_SHADER_COMPILER_KHR),
@@ -51,8 +52,9 @@
 #endif
 };
 
-std::map<GLenum, const char*> glErrorType = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
+std::map<GLenum, const char*> glErrorType =
+{
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && defined(GL_KHR_debug)
     X(GL_DEBUG_TYPE_ERROR_KHR),
     X(GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR),
     X(GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR),
@@ -63,8 +65,9 @@
 #endif
 };
 
-std::map<GLenum, const char*> glErrorSeverity = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
+std::map<GLenum, const char*> glErrorSeverity =
+{
+#if defined(HAS_GLES) && defined(TARGET_LINUX) && defined(GL_KHR_debug)
     X(GL_DEBUG_SEVERITY_HIGH_KHR),
     X(GL_DEBUG_SEVERITY_MEDIUM_KHR),
     X(GL_DEBUG_SEVERITY_LOW_KHR),
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/video/dialogs/GUIDialogVideoSettings.cpp xbmc-test-Nexus/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
--- xbmc-20.1-Nexus/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2023-03-11 22:16:38.000000000 +0000
+++ xbmc-test-Nexus/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2023-04-06 12:42:04.000000000 +0000
@@ -350,6 +350,10 @@
   entries.push_back(TranslatableIntegerSettingOption(16327, VS_INTERLACEMETHOD_VAAPI_BOB));
   entries.push_back(TranslatableIntegerSettingOption(16328, VS_INTERLACEMETHOD_VAAPI_MADI));
   entries.push_back(TranslatableIntegerSettingOption(16329, VS_INTERLACEMETHOD_VAAPI_MACI));
+  entries.push_back(TranslatableIntegerSettingOption(16337, VS_INTERLACEMETHOD_MMAL_ADVANCED));
+  entries.push_back(TranslatableIntegerSettingOption(16338, VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF));
+  entries.push_back(TranslatableIntegerSettingOption(16339, VS_INTERLACEMETHOD_MMAL_BOB));
+  entries.push_back(TranslatableIntegerSettingOption(16340, VS_INTERLACEMETHOD_MMAL_BOB_HALF));
   entries.push_back(TranslatableIntegerSettingOption(16320, VS_INTERLACEMETHOD_DXVA_AUTO));
 
   /* remove unsupported methods */
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/CMakeLists.txt xbmc-test-Nexus/xbmc/windowing/dmx/CMakeLists.txt
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/CMakeLists.txt	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/CMakeLists.txt	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,18 @@
+set(SOURCES DmxUtils.cpp
+            DmxDPMSSupport.cpp
+            VideoSyncDmx.cpp
+            WinSystemDmx.cpp
+            WinSystemDmxEGLContext.cpp)
+
+set(HEADERS DmxUtils.h
+            DmxDPMSSupport.h
+            VideoSyncDmx.h
+            WinSystemDmx.h
+            WinSystemDmxEGLContext.h)
+
+if(OPENGLES_FOUND)
+  list(APPEND SOURCES WinSystemDmxGLESContext.cpp)
+  list(APPEND HEADERS WinSystemDmxGLESContext.h)
+endif()
+
+core_add_library(windowing_dmx)
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.cpp xbmc-test-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.cpp	2023-03-31 10:25:11.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+ *  Copyright (C) 2009-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DmxDPMSSupport.h"
+
+#include "ServiceBroker.h"
+#include "windowing/dmx/WinSystemDmx.h"
+
+using namespace KODI::WINDOWING::DMX;
+
+CDmxDPMSSupport::CDmxDPMSSupport()
+{
+  m_supportedModes.push_back(OFF);
+}
+
+bool CDmxDPMSSupport::EnablePowerSaving(PowerSavingMode mode)
+{
+  auto winSystem = dynamic_cast<CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+  if (!winSystem)
+    return false;
+
+  switch (mode)
+  {
+    case OFF:
+      return winSystem->Hide();
+    default:
+      return false;
+  }
+}
+
+bool CDmxDPMSSupport::DisablePowerSaving()
+{
+  auto winSystem = dynamic_cast<CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+  if (!winSystem)
+    return false;
+
+  return winSystem->Show();
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.h xbmc-test-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/DmxDPMSSupport.h	2023-03-29 12:12:33.000000000 +0000
@@ -0,0 +1,22 @@
+/*
+ *  Copyright (C) 2009-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "powermanagement/DPMSSupport.h"
+
+#include <memory>
+
+class CDmxDPMSSupport : public CDPMSSupport
+{
+public:
+  CDmxDPMSSupport();
+  ~CDmxDPMSSupport() override = default;
+
+protected:
+  bool EnablePowerSaving(PowerSavingMode mode) override;
+  bool DisablePowerSaving() override;
+};
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxUtils.cpp xbmc-test-Nexus/xbmc/windowing/dmx/DmxUtils.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxUtils.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/DmxUtils.cpp	2023-04-09 12:33:33.959314876 +0000
@@ -0,0 +1,610 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DmxUtils.h"
+
+#include "threads/SingleLock.h"
+#include "utils/StringUtils.h"
+#include "utils/TimeUtils.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+
+#include <float.h>
+#include <fstream>
+#include <mutex>
+
+#include <interface/vcsm/user-vcsm.h>
+#include <sys/ioctl.h>
+
+using namespace KODI::WINDOWING::DMX;
+
+namespace
+{
+std::once_flag flag;
+}
+
+#define DISPMANX_ID_DEFAULT DISPMANX_ID_HDMI
+
+CDmxUtils::CDmxUtils()
+{
+  m_initialized = false;
+}
+
+bool CDmxUtils::Initialize()
+{
+  if (m_initialized)
+    return true;
+
+  if (vcos_init() == VCOS_SUCCESS)
+  {
+    if (vcsm_init_ex(0, -1) == VCOS_SUCCESS)
+    {
+      if (vchi_initialise(&m_vchi) == VCOS_SUCCESS)
+      {
+        m_connections =
+            (VCHI_CONNECTION_T*)vcos_malloc(sizeof(VCHI_CONNECTION_T), "vchi connections");
+        if (vchi_connect(&m_connections, 1, m_vchi) == VCOS_SUCCESS)
+        {
+          if (vc_vchi_tv_init(m_vchi, &m_connections, 1) == VCOS_SUCCESS)
+          {
+            vc_vchi_dispmanx_init(m_vchi, &m_connections, 1);
+            m_initialized = true;
+          }
+          else
+            CLog::Log(LOGERROR, "CDmxUtils::{} - unable to initialize tv service", __FUNCTION__);
+        }
+        else
+          CLog::Log(LOGERROR, "CDmxUtils::{} - unable to connect vchi", __FUNCTION__);
+      }
+      else
+        CLog::Log(LOGERROR, "CDmxUtils::{} - unable to initialize vchi", __FUNCTION__);
+    }
+    else
+      CLog::Log(LOGERROR, "CDmxUtils::{} - unable to initialize vcsm", __FUNCTION__);
+  }
+  else
+    CLog::Log(LOGERROR, "CDmxUtils::{} - unable to initialize vcos", __FUNCTION__);
+
+  if (!m_initialized)
+  {
+    Deinitialize();
+    return false;
+  }
+  return true;
+}
+
+void CDmxUtils::Deinitialize()
+{
+  if (m_initialized)
+  {
+    CloseDisplay();
+    vc_dispmanx_stop();
+    vc_vchi_tv_stop();
+    if (m_vchi)
+    {
+      if (vchi_disconnect(m_vchi) == VCOS_SUCCESS)
+        m_vchi = nullptr;
+    }
+    if (m_connections)
+    {
+      vcos_free(m_connections);
+      m_connections = nullptr;
+    }
+    vcos_deinit();
+    vcsm_exit();
+  }
+}
+
+bool CDmxUtils::OpenDisplay()
+{
+  if (m_display != DISPMANX_NO_HANDLE)
+    return true;
+
+  std::unique_lock<CCriticalSection> lock(m_updateLock);
+  m_display = vc_dispmanx_display_open(0);
+  if (m_display != (unsigned)DISPMANX_INVALID &&
+      vc_dispmanx_vsync_callback(m_display, CDmxUtils::VerticalSyncCallback, (void*)this) ==
+          DISPMANX_SUCCESS)
+  {
+    if (vc_dispmanx_display_get_info(m_display, &m_displayInfo) != DISPMANX_SUCCESS)
+    {
+      m_displayInfo.width = 0;
+      m_displayInfo.height = 0;
+    }
+    return true;
+  }
+  else
+  {
+    m_display = DISPMANX_NO_HANDLE;
+  }
+
+  return false;
+}
+
+void CDmxUtils::CloseDisplay()
+{
+  if (m_display != DISPMANX_NO_HANDLE)
+  {
+    DestroySurface();
+    std::unique_lock<CCriticalSection> lock(m_updateLock);
+    vc_dispmanx_vsync_callback(m_display, NULL, NULL);
+    vc_dispmanx_display_close(m_display);
+    m_display = DISPMANX_NO_HANDLE;
+  }
+}
+
+bool CDmxUtils::GetHdmiProperty(HDMI_PROPERTY_T property, uint32_t* param1, uint32_t* param2)
+{
+
+  HDMI_PROPERTY_PARAM_T p;
+  memset(&p, 0, sizeof(HDMI_PROPERTY_PARAM_T));
+  p.property = property;
+  if (vc_tv_hdmi_get_property(&p) == VCOS_SUCCESS)
+  {
+    if (param1)
+      *param1 = p.param1;
+    if (param2)
+      *param2 = p.param2;
+    return true;
+  }
+  return false;
+}
+
+bool CDmxUtils::SetHdmiProperty(HDMI_PROPERTY_T property, uint32_t param1, uint32_t param2)
+{
+  HDMI_PROPERTY_PARAM_T p;
+  memset(&p, 0, sizeof(HDMI_PROPERTY_PARAM_T));
+  p.property = property;
+  p.param1 = param1;
+  p.param2 = param2;
+  return vc_tv_hdmi_set_property(&p) == VCOS_SUCCESS;
+}
+
+HDMI_PIXEL_CLOCK_TYPE_T CDmxUtils::GetHdmiPixelClock(float refresh_rate)
+{
+  int frame_rate = (int)(refresh_rate + 0.5f);
+  if (fabsf(refresh_rate * (1001.0f / 1000.0f) - frame_rate) < fabsf(refresh_rate - frame_rate))
+    return HDMI_PIXEL_CLOCK_TYPE_NTSC;
+  else
+    return HDMI_PIXEL_CLOCK_TYPE_PAL;
+}
+
+float CDmxUtils::GetHdmiPixelRatio(uint32_t aspect_type, uint32_t width, uint32_t height)
+{
+  float result = 1.0f;
+  switch ((HDMI_ASPECT_T)aspect_type)
+  {
+    case HDMI_ASPECT_4_3:
+      result = 4.0f / 3.0f;
+      break;
+    case HDMI_ASPECT_14_9:
+      result = 14.0f / 9.0f;
+      break;
+    case HDMI_ASPECT_16_9:
+      result = 16.0f / 9.0f;
+      break;
+    case HDMI_ASPECT_5_4:
+      result = 5.0f / 4.0f;
+      break;
+    case HDMI_ASPECT_16_10:
+      result = 16.0f / 10.0f;
+      break;
+    case HDMI_ASPECT_15_9:
+      result = 15.0f / 9.0f;
+      break;
+    case HDMI_ASPECT_64_27:
+      result = 64.0f / 27.0f;
+      break;
+    case HDMI_ASPECT_256_135:
+      result = 256.0f / 135.0f;
+      break;
+    case HDMI_ASPECT_UNKNOWN:
+    default:
+      return result;
+  }
+  return result / ((float)width / (float)height);
+}
+
+bool CDmxUtils::GetHdmiResolution(TV_SUPPORTED_MODE_NEW_T* mode, RESOLUTION_INFO& res)
+{
+  if (mode->code == 0)
+    return false;
+
+  if (mode->code == HDMI_RES_GROUP_CEA && mode->struct_3d_mask != 0)
+  {
+    if (mode->struct_3d_mask & HDMI_3D_STRUCT_TOP_AND_BOTTOM)
+      res.dwFlags = D3DPRESENTFLAG_MODE3DTB;
+    else
+      res.dwFlags = D3DPRESENTFLAG_MODE3DSBS;
+  }
+  else if (mode->scan_mode == 1)
+    res.dwFlags = D3DPRESENTFLAG_INTERLACED;
+  else
+    res.dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+
+  res.dwFlags |= ((mode->code) << 24) | ((mode->group) << 16);
+  res.bFullScreen = true;
+  res.fRefreshRate = (float)mode->frame_rate;
+  res.iWidth = mode->width;
+  res.iHeight = mode->height;
+  res.iScreenWidth = mode->width;
+  res.iScreenHeight = mode->height;
+  res.fPixelRatio = GetHdmiPixelRatio(mode->aspect_ratio, mode->width, mode->height);
+  res.iSubtitles = (int)(0.965f * (float)mode->height);
+  res.strMode =
+      StringUtils::Format("{}x{}{} @ {:.6f} Hz", res.iScreenWidth, res.iScreenHeight,
+                          res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "", res.fRefreshRate);
+  return true;
+}
+
+int CDmxUtils::GetHdmiModes(HDMI_RES_GROUP_T group, TV_SUPPORTED_MODE_NEW_T** modes)
+{
+  int max_count =
+      vc_tv_hdmi_get_supported_modes_new_id(DISPMANX_ID_DEFAULT, group, NULL, 0, NULL, NULL);
+  if (max_count > 0)
+  {
+    *modes = new TV_SUPPORTED_MODE_NEW_T[max_count];
+    return vc_tv_hdmi_get_supported_modes_new_id(DISPMANX_ID_DEFAULT, group, *modes, max_count,
+                                                 NULL, NULL);
+  }
+  return 0;
+}
+
+void CDmxUtils::ResolveHdmiModes(TV_SUPPORTED_MODE_NEW_T* modes, uint32_t count)
+{
+  TV_SUPPORTED_MODE_NEW_T* mode;
+  mode = modes;
+  for (uint32_t i = 0; i < count; i++, mode++)
+  {
+    RESOLUTION_INFO res;
+    if (!GetHdmiResolution(mode, res))
+      continue;
+
+    bool found_res = false;
+    for (auto& resolution : m_resolutions)
+    {
+      if (resolution.iScreenWidth == res.iScreenWidth &&
+          resolution.iScreenHeight == res.iScreenHeight &&
+          resolution.iWidth == res.iWidth && // width
+          resolution.iHeight == res.iHeight && // height
+          fabs(resolution.fRefreshRate - res.fRefreshRate) < FLT_EPSILON &&
+          (resolution.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK))
+      {
+        found_res = true;
+        break;
+      }
+    }
+    if (!found_res)
+    {
+      m_resolutions.push_back(res);
+    }
+  }
+}
+
+std::vector<RESOLUTION_INFO> CDmxUtils::GetSupportedResolutions(bool probe)
+{
+  if (probe)
+  {
+    TV_SUPPORTED_MODE_NEW_T* cea_modes;
+    TV_SUPPORTED_MODE_NEW_T* dmt_modes;
+    uint32_t cea_mode_count = GetHdmiModes(HDMI_RES_GROUP_CEA, &cea_modes);
+    uint32_t dmt_mode_count = GetHdmiModes(HDMI_RES_GROUP_DMT, &dmt_modes);
+
+    GetCurrentResolution(probe);
+
+    m_resolutions.clear();
+    m_resolutions.reserve(cea_mode_count + dmt_mode_count);
+
+    ResolveHdmiModes(cea_modes, cea_mode_count);
+    ResolveHdmiModes(dmt_modes, dmt_mode_count);
+
+    if (cea_mode_count > 0)
+      delete cea_modes;
+    if (dmt_mode_count > 0)
+      delete dmt_modes;
+  }
+  return m_resolutions;
+}
+
+const RESOLUTION_INFO& CDmxUtils::GetCurrentResolution(bool probe)
+{
+  if (probe)
+  {
+    TV_DISPLAY_STATE_T tv_state;
+    memset(&tv_state, 0, sizeof(TV_DISPLAY_STATE_T));
+    vc_tv_get_display_state_id(DISPMANX_ID_DEFAULT, &tv_state);
+
+    if ((tv_state.state & VC_HDMI_HDMI) != 0)
+    {
+      RESOLUTION_INFO res;
+      TV_SUPPORTED_MODE_NEW_T mode;
+
+      memset(&mode, 0, sizeof(TV_SUPPORTED_MODE_NEW_T));
+      mode.scan_mode = tv_state.display.hdmi.scan_mode;
+      mode.code = tv_state.display.hdmi.mode;
+      mode.width = tv_state.display.hdmi.width;
+      mode.height = tv_state.display.hdmi.height;
+      mode.frame_rate = tv_state.display.hdmi.frame_rate;
+      mode.aspect_ratio = tv_state.display.hdmi.display_options.aspect;
+      mode.struct_3d_mask = tv_state.display.hdmi.format_3d;
+      if (GetHdmiResolution(&mode, res))
+        m_currentResolution = res;
+    }
+  }
+  return m_currentResolution;
+}
+
+static void vc_tv_hdmi_sync_callback(void* userdata,
+                                     uint32_t reason,
+                                     uint32_t param1,
+                                     uint32_t param2)
+{
+  switch (reason)
+  {
+    case VC_HDMI_UNPLUGGED:
+    case VC_HDMI_STANDBY:
+      break;
+    case VC_SDTV_NTSC:
+    case VC_SDTV_PAL:
+    case VC_HDMI_HDMI:
+    case VC_HDMI_DVI:
+      sem_post((sem_t*)userdata);
+      break;
+  }
+}
+
+bool CDmxUtils::SetResolution(const RESOLUTION_INFO& res)
+{
+  HDMI_RES_GROUP_T group = static_cast<HDMI_RES_GROUP_T>((res.dwFlags >> 16) & 0xff);
+  uint32_t mode = (res.dwFlags >> 24) & 0xff;
+  bool result = false;
+
+  if (group != HDMI_RES_GROUP_INVALID && mode > 0)
+  {
+    sem_t hdmi_sync;
+    SetHdmiProperty(HDMI_PROPERTY_PIXEL_CLOCK_TYPE, GetHdmiPixelClock(res.fRefreshRate), 0);
+
+    sem_init(&hdmi_sync, 0, 0);
+    vc_tv_register_callback(vc_tv_hdmi_sync_callback, &hdmi_sync);
+
+    if (vc_tv_hdmi_power_on_explicit_new_id(DISPMANX_ID_HDMI, HDMI_MODE_HDMI, group, mode) == 0)
+    {
+      sem_wait(&hdmi_sync);
+      m_currentResolution = res;
+      result = true;
+    }
+    vc_tv_unregister_callback(vc_tv_hdmi_sync_callback);
+    sem_destroy(&hdmi_sync);
+  }
+  return result;
+}
+
+bool CDmxUtils::IsCurrentResolution(const RESOLUTION_INFO& res)
+{
+  RESOLUTION_INFO current = GetCurrentResolution(true);
+  return (current.iScreenWidth == res.iScreenWidth && current.iScreenHeight == res.iScreenHeight &&
+          fabs(current.fRefreshRate - res.fRefreshRate) < FLT_EPSILON &&
+          (current.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK));
+}
+
+void CDmxUtils::BlankFrameBuffer(bool blank)
+{
+  std::ofstream m_output{"/sys/class/graphics/fb0/blank"};
+  m_output << std::string(blank ? "1" : "0");
+  m_output.close();
+}
+
+bool CDmxUtils::CreateSurface(EGLSurface surface, RESOLUTION_INFO& res)
+{
+  std::unique_lock<CCriticalSection> lock(m_updateLock);
+  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+  if (update != DISPMANX_NO_HANDLE)
+  {
+    VC_DISPMANX_ALPHA_T alpha;
+    DISPMANX_CLAMP_T clamp;
+    memset(&alpha, 0x0, sizeof(VC_DISPMANX_ALPHA_T));
+    memset(&clamp, 0x0, sizeof(DISPMANX_CLAMP_T));
+
+    m_layer = 1;
+
+    m_screenRectangle.x = 0;
+    m_screenRectangle.y = 0;
+    m_screenRectangle.width = res.iScreenWidth;
+    m_screenRectangle.height = res.iScreenHeight;
+
+    m_sourceRectangle.x = 0;
+    m_sourceRectangle.y = 0;
+    m_sourceRectangle.width = res.iWidth << 16;
+    m_sourceRectangle.height = res.iHeight << 16;
+
+    alpha.flags = DISPMANX_FLAGS_ALPHA_FROM_SOURCE;
+
+    m_element = vc_dispmanx_element_add(update, m_display,
+                                        m_layer, // layer
+                                        &m_screenRectangle,
+                                        (DISPMANX_RESOURCE_HANDLE_T)0, // src
+                                        &m_sourceRectangle,
+                                        DISPMANX_PROTECTION_NONE, // protection mode
+                                        &alpha, // alpha
+                                        &clamp, // clamp
+                                        DISPMANX_NO_ROTATE); // transform
+
+    if (m_element != (unsigned)DISPMANX_INVALID)
+    {
+      EGL_DISPMANX_WINDOW_T* window = nullptr;
+      memset(surface, 0, sizeof(EGL_DISPMANX_WINDOW_T));
+      window = (EGL_DISPMANX_WINDOW_T*)surface;
+
+      window->element = m_element;
+      window->width = res.iWidth;
+      window->height = res.iHeight;
+      vc_dispmanx_display_set_background(update, m_display, 0x00, 0x00, 0x00);
+      return vc_dispmanx_update_submit_sync(update) == DISPMANX_SUCCESS;
+    }
+    else
+    {
+      m_element = DISPMANX_NO_HANDLE;
+    }
+  }
+
+  return m_element != DISPMANX_NO_HANDLE;
+}
+
+void CDmxUtils::DestroySurface()
+{
+  if (m_element != DISPMANX_NO_HANDLE)
+  {
+    std::unique_lock<CCriticalSection> lock(m_updateLock);
+    DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+    vc_dispmanx_element_remove(update, m_element);
+    vc_dispmanx_update_submit_sync(update);
+    m_element = DISPMANX_NO_HANDLE;
+  }
+}
+
+bool CDmxUtils::SetVisibility(bool visible)
+{
+  if (m_element != DISPMANX_NO_HANDLE)
+  {
+    int32_t layer = visible ? 1 : -1;
+    if (m_layer == layer)
+      return true;
+
+    std::unique_lock<CCriticalSection> lock(m_updateLock);
+    DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(VCOS_THREAD_PRI_ABOVE_NORMAL);
+    if (update == DISPMANX_NO_HANDLE)
+      return false;
+
+    if (visible)
+    {
+      m_screenRectangle.x = 0;
+      m_screenRectangle.y = 0;
+    }
+    else
+    {
+      m_screenRectangle.x = m_screenRectangle.width;
+      m_screenRectangle.y = m_screenRectangle.height;
+    }
+
+    int32_t result = vc_dispmanx_element_change_attributes(
+        update, m_element, 5, layer, 0, &m_screenRectangle, nullptr, 0, DISPMANX_NO_ROTATE);
+    if (result == DISPMANX_SUCCESS)
+      m_layer = layer;
+    return vc_dispmanx_update_submit_sync(update) == DISPMANX_SUCCESS && result == DISPMANX_SUCCESS;
+  }
+  return false;
+}
+
+bool CDmxUtils::ResizeWindow(int32_t width, int32_t height)
+{
+  if (m_element != DISPMANX_NO_HANDLE)
+  {
+    if (m_screenRectangle.width == width && m_screenRectangle.height == height)
+      return true;
+
+    if (m_screenRectangle.x == m_screenRectangle.width &&
+        m_screenRectangle.y == m_screenRectangle.height)
+    {
+      m_screenRectangle.x = width;
+      m_screenRectangle.y = height;
+    }
+
+    m_screenRectangle.width = width;
+    m_screenRectangle.height = height;
+
+    std::unique_lock<CCriticalSection> lock(m_updateLock);
+    DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+    int32_t result = vc_dispmanx_element_change_attributes(
+        update, m_element, 4, 0, 0, &m_screenRectangle, nullptr, 0, DISPMANX_NO_ROTATE);
+
+    return vc_dispmanx_update_submit_sync(update) == DISPMANX_SUCCESS && result == DISPMANX_SUCCESS;
+  }
+  return false;
+}
+
+bool CDmxUtils::ResizeSurface(int32_t width, int32_t height)
+{
+  if (m_element != DISPMANX_NO_HANDLE)
+  {
+    m_sourceRectangle.x = 0;
+    m_sourceRectangle.y = 0;
+
+    m_sourceRectangle.width = width << 16;
+    m_sourceRectangle.height = height << 16;
+
+    std::unique_lock<CCriticalSection> lock(m_updateLock);
+    DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+    int32_t result = vc_dispmanx_element_change_attributes(
+        update, m_element, 8, 0, 0, nullptr, &m_sourceRectangle, 0, DISPMANX_NO_ROTATE);
+
+    return vc_dispmanx_update_submit_sync(update) == DISPMANX_SUCCESS && result == DISPMANX_SUCCESS;
+  }
+  return false;
+}
+
+bool CDmxUtils::ReadPixels(uint32_t x,
+                           uint32_t y,
+                           uint32_t width,
+                           uint32_t height,
+                           VC_IMAGE_TYPE_T format,
+                           DISPMANX_TRANSFORM_T transform,
+                           void* pixels,
+                           uint32_t pitch)
+{
+  uint32_t flags = 0;
+
+  if (m_display != DISPMANX_NO_HANDLE)
+  {
+    DISPMANX_RESOURCE_HANDLE_T resource;
+    uint32_t unused;
+    resource = vc_dispmanx_resource_create(format, width, height, &unused);
+
+    if (resource != (unsigned)DISPMANX_INVALID)
+    {
+      bool result = false;
+      if (vc_dispmanx_snapshot(m_display, resource, transform) == DISPMANX_SUCCESS)
+      {
+        VC_RECT_T rect;
+        vc_dispmanx_rect_set(&rect, x, y, width, height);
+        result = vc_dispmanx_resource_read_data(resource, &rect, pixels, pitch) == DISPMANX_SUCCESS;
+      }
+      vc_dispmanx_resource_delete(resource);
+      return result;
+    }
+  }
+  return false;
+}
+
+uint64_t CDmxUtils::WaitVerticalSync(uint64_t sequence, uint64_t* time, uint32_t wait_ms)
+{
+  std::unique_lock<CCriticalSection> vlock(m_vsyncLock);
+  if (m_vsyncCount < sequence)
+  {
+    if (wait_ms > 0)
+      m_vsyncCondition.wait(vlock, std::chrono::milliseconds(wait_ms));
+    else
+      while (m_vsyncCount < sequence)
+        m_vsyncCondition.wait(vlock);
+  }
+  if (time)
+    *time = ((int64_t)m_vsyncTime.tv_sec * 1000000000L) + m_vsyncTime.tv_nsec;
+  return m_vsyncCount;
+}
+
+void CDmxUtils::VerticalSyncCallback(DISPMANX_UPDATE_HANDLE_T u, void* arg)
+{
+  CDmxUtils* dmx = static_cast<CDmxUtils*>(arg);
+  if (dmx)
+  {
+    std::unique_lock<CCriticalSection> lock(dmx->m_vsyncLock);
+    clock_gettime(CLOCK_MONOTONIC_RAW, &dmx->m_vsyncTime);
+    dmx->m_vsyncCount++;
+    lock.unlock();
+    dmx->m_vsyncCondition.notifyAll();
+  }
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxUtils.h xbmc-test-Nexus/xbmc/windowing/dmx/DmxUtils.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/DmxUtils.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/DmxUtils.h	2023-04-06 20:49:35.607487018 +0000
@@ -0,0 +1,122 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "threads/Condition.h"
+#include "threads/CriticalSection.h"
+#include "utils/EGLUtils.h"
+#include "windowing/Resolution.h"
+
+#include <memory>
+#include <queue>
+
+extern "C"
+{
+#include <interface/vchiq_arm/vchiq_if.h>
+#include <interface/vctypes/vc_image_types.h>
+#include <interface/vmcs_host/vc_cecservice.h>
+#include <interface/vmcs_host/vc_dispmanx_types.h>
+#include <interface/vmcs_host/vc_hdmi.h>
+#include <interface/vmcs_host/vc_tvservice.h>
+#include <interface/vmcs_host/vc_tvservice_defs.h>
+#include <interface/vmcs_host/vc_vchi_gencmd.h>
+}
+
+namespace KODI
+{
+namespace WINDOWING
+{
+namespace DMX
+{
+
+/**
+ * @brief A wrapper for DispmanX C classes.
+ *
+ */
+class CDmxUtils
+{
+public:
+  CDmxUtils(const CDmxUtils&) = delete;
+  CDmxUtils& operator=(const CDmxUtils&) = delete;
+
+  CDmxUtils();
+  ~CDmxUtils() = default;
+
+  bool Initialize();
+  void Deinitialize();
+
+  bool OpenDisplay();
+  void CloseDisplay();
+
+  const RESOLUTION_INFO& GetCurrentResolution(bool probe = false);
+  std::vector<RESOLUTION_INFO> GetSupportedResolutions(bool probe = false);
+
+  bool SetResolution(const RESOLUTION_INFO& res);
+  bool IsCurrentResolution(const RESOLUTION_INFO& res);
+
+  bool CreateSurface(EGLSurface surface, RESOLUTION_INFO& res);
+  void DestroySurface();
+
+  bool SetVisibility(bool visible);
+  bool ResizeWindow(int32_t width, int32_t height);
+  bool ResizeSurface(int32_t width, int32_t height);
+
+  void BlankFrameBuffer(bool blank);
+
+  bool ReadPixels(uint32_t x,
+                  uint32_t y,
+                  uint32_t width,
+                  uint32_t height,
+                  VC_IMAGE_TYPE_T format,
+                  DISPMANX_TRANSFORM_T transform,
+                  void* pixels,
+                  uint32_t pitch);
+
+  uint64_t WaitVerticalSync(uint64_t sequence, uint64_t* time, uint32_t wait_ms);
+
+protected:
+  bool m_initialized{false};
+
+private:
+  static void VerticalSyncCallback(DISPMANX_UPDATE_HANDLE_T u, void* arg);
+
+  bool GetHdmiProperty(HDMI_PROPERTY_T property, uint32_t* param1, uint32_t* param2);
+  bool SetHdmiProperty(HDMI_PROPERTY_T property, uint32_t param1, uint32_t param2);
+
+  HDMI_PIXEL_CLOCK_TYPE_T GetHdmiPixelClock(float refresh_rate);
+  float GetHdmiPixelRatio(uint32_t aspect_type, uint32_t width, uint32_t height);
+  bool GetHdmiResolution(TV_SUPPORTED_MODE_NEW_T* mode, RESOLUTION_INFO& res);
+
+  int GetHdmiModes(HDMI_RES_GROUP_T group, TV_SUPPORTED_MODE_NEW_T** modes);
+  void ResolveHdmiModes(TV_SUPPORTED_MODE_NEW_T* modes, uint32_t count);
+
+  CCriticalSection m_updateLock;
+
+  CCriticalSection m_vsyncLock;
+  uint64_t m_vsyncCount;
+  struct timespec m_vsyncTime;
+  XbmcThreads::ConditionVariable m_vsyncCondition;
+
+  VCHI_INSTANCE_T m_vchi{nullptr};
+  VCHI_CONNECTION_T* m_connections{nullptr};
+  int32_t m_layer{1};
+  std::vector<RESOLUTION_INFO> m_resolutions;
+  RESOLUTION_INFO m_currentResolution;
+
+  DISPMANX_MODEINFO_T m_displayInfo;
+  VC_RECT_T m_sourceRectangle;
+  VC_RECT_T m_screenRectangle;
+
+  DISPMANX_DISPLAY_HANDLE_T m_display{DISPMANX_NO_HANDLE};
+  DISPMANX_ELEMENT_HANDLE_T m_element{DISPMANX_NO_HANDLE};
+};
+
+} // namespace DMX
+} // namespace WINDOWING
+} // namespace KODI
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/VideoSyncDmx.cpp xbmc-test-Nexus/xbmc/windowing/dmx/VideoSyncDmx.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/VideoSyncDmx.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/VideoSyncDmx.cpp	2023-04-08 15:07:09.882008346 +0000
@@ -0,0 +1,69 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoSyncDmx.h"
+
+#include "ServiceBroker.h"
+#include "threads/Thread.h"
+#include "utils/TimeUtils.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/WinSystem.h"
+
+bool CVideoSyncDmx::Setup(PUPDATECLOCK func)
+{
+  m_winSystem = dynamic_cast<KODI::WINDOWING::DMX::CWinSystemDmx*>(CServiceBroker::GetWinSystem());
+
+  if (!m_winSystem)
+  {
+    CLog::Log(LOGWARNING, "CVideoSyncDmx::{}: failed to get winSystem", __FUNCTION__);
+    return false;
+  }
+
+  UpdateClock = func;
+  m_abort = false;
+  m_winSystem->Register(this);
+  return true;
+}
+
+void CVideoSyncDmx::Run(CEvent& stopEvent)
+{
+  CThread::GetCurrentThread()->SetPriority(ThreadPriority::ABOVE_NORMAL);
+  uint64_t sequence = 0, last_sequence = 0, time = 0, skew = 0;
+
+  last_sequence = m_winSystem->WaitVerticalSync(m_winSystem->WaitVerticalSync(0) + 1, &time);
+  skew = CurrentHostCounter() - time;
+  while (!stopEvent.Signaled() && !m_abort)
+  {
+    sequence = m_winSystem->WaitVerticalSync(last_sequence + 1, &time);
+    UpdateClock(sequence - last_sequence, time + skew, m_refClock);
+    last_sequence = sequence;
+  }
+}
+
+void CVideoSyncDmx::Cleanup()
+{
+  m_winSystem->Unregister(this);
+}
+
+float CVideoSyncDmx::GetFps()
+{
+  m_fps = m_winSystem->GetGfxContext().GetFPS();
+  return m_fps;
+}
+
+void CVideoSyncDmx::OnResetDisplay()
+{
+  m_abort = true;
+}
+
+void CVideoSyncDmx::RefreshChanged()
+{
+  if (m_fps != m_winSystem->GetGfxContext().GetFPS())
+    m_abort = true;
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/VideoSyncDmx.h xbmc-test-Nexus/xbmc/windowing/dmx/VideoSyncDmx.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/VideoSyncDmx.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/VideoSyncDmx.h	2023-04-08 12:09:05.139127018 +0000
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "guilib/DispResource.h"
+#include "windowing/VideoSync.h"
+#include "windowing/dmx/WinSystemDmx.h"
+
+class CVideoSyncDmx : public CVideoSync, IDispResource
+{
+public:
+  explicit CVideoSyncDmx(void* clock) : CVideoSync(clock){};
+  CVideoSyncDmx() = delete;
+  ~CVideoSyncDmx() override = default;
+  bool Setup(PUPDATECLOCK func) override;
+  void Run(CEvent& stopEvent) override;
+  void Cleanup() override;
+  float GetFps() override;
+  void OnResetDisplay() override;
+  void RefreshChanged() override;
+
+private:
+  std::atomic<bool> m_abort{false};
+  KODI::WINDOWING::DMX::CWinSystemDmx* m_winSystem{nullptr};
+};
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmx.cpp xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmx.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmx.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmx.cpp	2023-04-06 18:49:09.394458269 +0000
@@ -0,0 +1,257 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemDmx.h"
+
+#include "DmxDPMSSupport.h"
+#include "OptionalsReg.h"
+#include "ServiceBroker.h"
+#include "messaging/ApplicationMessenger.h"
+#include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "threads/CriticalSection.h"
+#include "threads/SingleLock.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+#include "windowing/dmx/VideoSyncDmx.h"
+
+#include <float.h>
+#include <mutex>
+#include <string.h>
+
+#include "system_gl.h"
+
+using namespace KODI::WINDOWING::DMX;
+using namespace std::chrono_literals;
+
+CWinSystemDmx::CWinSystemDmx() : m_DMX(new CDmxUtils), m_libinput(new CLibInputHandler)
+{
+  if (!m_DMX->Initialize())
+    throw std::runtime_error("Failed to initialize DMX!");
+
+  m_dpms = std::make_shared<CDmxDPMSSupport>();
+  m_libinput->Start();
+  m_dispReset = false;
+  m_visible = false;
+}
+
+bool CWinSystemDmx::InitWindowSystem()
+{
+  if (!CServiceBroker::GetSettingsComponent())
+    return false;
+
+  m_settings = CServiceBroker::GetSettingsComponent()->GetSettings();
+  if (!m_settings)
+    return false;
+
+  auto setting = m_settings->GetSetting(CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGE);
+  if (setting)
+    setting->SetVisible(true);
+
+  setting = m_settings->GetSetting("videoscreen.limitguisize");
+  if (setting)
+    setting->SetVisible(true);
+
+  CLog::Log(LOGDEBUG, "CWinSystemDmx::{} - initialized DMX", __FUNCTION__);
+  if (CWinSystemBase::InitWindowSystem())
+  {
+    m_DMX->BlankFrameBuffer(true);
+    return true;
+  }
+  return false;
+}
+
+bool CWinSystemDmx::DestroyWindowSystem()
+{
+  CLog::Log(LOGDEBUG, "CWinSystemDmx::{} - deinitialized DMX", __FUNCTION__);
+  DestroyWindow();
+  m_DMX->BlankFrameBuffer(false);
+  m_libinput.reset();
+  m_DMX->Deinitialize();
+  return true;
+}
+
+void CWinSystemDmx::UpdateResolutions()
+{
+  auto resolutions = m_DMX->GetSupportedResolutions(true);
+  if (resolutions.empty())
+  {
+    CLog::Log(LOGWARNING, "CWinSystemDmx::{} - Failed to get resolutions", __FUNCTION__);
+  }
+  else
+  {
+    const auto& current = m_DMX->GetCurrentResolution();
+
+    CDisplaySettings::GetInstance().ClearCustomResolutions();
+    CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = current;
+    for (auto& res : resolutions)
+    {
+      CServiceBroker::GetWinSystem()->GetGfxContext().ResetOverscan(res);
+      CDisplaySettings::GetInstance().AddResolutionInfo(res);
+
+      if (current.iScreenWidth == res.iScreenWidth && current.iScreenHeight == res.iScreenHeight &&
+          current.iWidth == res.iWidth && current.iHeight == res.iHeight &&
+          fabs(current.fRefreshRate - res.fRefreshRate) < FLT_EPSILON &&
+          (current.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK))
+      {
+        CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = res;
+      }
+      CLog::Log(LOGINFO, "Found resolution {}x{} with {}x{}{} @ {:f} Hz", res.iWidth, res.iHeight,
+                res.iScreenWidth, res.iScreenHeight,
+                res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "", res.fRefreshRate);
+    }
+  }
+
+  CDisplaySettings::GetInstance().ApplyCalibrations();
+}
+
+bool CWinSystemDmx::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  if (m_DMX->ResizeWindow(newWidth, newHeight))
+  {
+    m_nWidth = newWidth;
+    m_nHeight = newHeight;
+    return true;
+  }
+
+  return false;
+}
+
+bool CWinSystemDmx::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  if (!m_DMX->IsCurrentResolution(res))
+  {
+    OnLostDevice();
+
+    if (!m_DMX->SetResolution(res))
+    {
+      CLog::Log(LOGERROR, "CWinSystemDmx::{} - failed to set HDMI mode", __FUNCTION__);
+      return false;
+    }
+
+    auto delay =
+        std::chrono::milliseconds(CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
+                                      "videoscreen.delayrefreshchange") *
+                                  100);
+    if (delay > 0ms)
+      m_dispResetTimer.Set(delay);
+  }
+  int newWidth = res.iWidth;
+  int newHeight = res.iHeight;
+  if (fullScreen)
+  {
+    newWidth = res.iScreenWidth;
+    newHeight = res.iScreenHeight;
+  }
+  if (m_DMX->ResizeWindow(newWidth, newHeight))
+  {
+    m_nWidth = newWidth;
+    m_nHeight = newHeight;
+    m_bFullScreen = fullScreen;
+    if (res.iWidth > 0 && res.iHeight > 0)
+      return m_DMX->ResizeSurface(res.iWidth, res.iHeight);
+    else
+      return m_DMX->ResizeSurface(newWidth, newHeight);
+  }
+
+  return false;
+}
+
+bool CWinSystemDmx::DisplayHardwareScalingEnabled()
+{
+  return true;
+}
+
+void CWinSystemDmx::UpdateDisplayHardwareScaling(const RESOLUTION_INFO& resInfo)
+{
+  m_DMX->ResizeSurface(resInfo.iWidth, resInfo.iHeight);
+}
+
+bool CWinSystemDmx::UseLimitedColor()
+{
+  return m_settings->GetBool(CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGE);
+}
+
+bool CWinSystemDmx::Hide()
+{
+  if (!m_visible)
+    return true;
+  else if (!m_DMX->SetVisibility(false))
+    return false;
+
+  m_visible = false;
+  return true;
+}
+
+bool CWinSystemDmx::Show(bool raise)
+{
+  if (m_visible)
+    return true;
+  else if (!m_DMX->SetVisibility(true))
+    return false;
+
+  m_visible = true;
+  return true;
+}
+
+void CWinSystemDmx::Register(IDispResource* resource)
+{
+  std::unique_lock<CCriticalSection> lock(m_resourceSection);
+  m_resources.push_back(resource);
+}
+
+void CWinSystemDmx::Unregister(IDispResource* resource)
+{
+  std::unique_lock<CCriticalSection> lock(m_resourceSection);
+  std::vector<IDispResource*>::iterator i = find(m_resources.begin(), m_resources.end(), resource);
+  if (i != m_resources.end())
+  {
+    m_resources.erase(i);
+  }
+}
+
+bool CWinSystemDmx::ReadPixels(
+    int32_t x, int32_t y, int32_t width, int32_t height, uint32_t format, bool swap, void* pixels)
+{
+  VC_IMAGE_TYPE_T imgType = VC_IMAGE_1BPP;
+  uint32_t pitch = width;
+
+  if (format == GL_RGBA)
+  {
+    imgType = VC_IMAGE_RGBA32;
+    pitch *= 4;
+  }
+  else if (format == GL_RGB565)
+  {
+    imgType = VC_IMAGE_RGB565;
+    pitch *= 2;
+  }
+  DISPMANX_TRANSFORM_T transform = DISPMANX_NO_ROTATE;
+
+  if (swap)
+    transform = static_cast<DISPMANX_TRANSFORM_T>(transform | DISPMANX_SNAPSHOT_SWAP_RED_BLUE);
+
+  return m_DMX->ReadPixels(x, y, width, height, imgType, transform, pixels, pitch);
+}
+
+std::unique_ptr<CVideoSync> CWinSystemDmx::GetVideoSync(void* clock)
+{
+  return std::make_unique<CVideoSyncDmx>(clock);
+}
+
+void CWinSystemDmx::OnLostDevice()
+{
+  CLog::Log(LOGDEBUG, "CWinSystemDmx::{} - notify display change event", __FUNCTION__);
+  m_dispReset = true;
+
+  std::unique_lock<CCriticalSection> lock(m_resourceSection);
+  for (auto resource : m_resources)
+    resource->OnLostDisplay();
+}
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.cpp xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.cpp	2023-04-06 18:52:38.055110155 +0000
@@ -0,0 +1,156 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemDmxEGLContext.h"
+
+#include "OptionalsReg.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "utils/log.h"
+#include "windowing/GraphicContext.h"
+
+#include <float.h>
+
+using namespace KODI::WINDOWING::DMX;
+
+CWinSystemDmxEGLContext::CWinSystemDmxEGLContext() : CWinSystemDmx()
+{
+  m_eglDisplay = EGL_NO_DISPLAY;
+  m_eglSurface = EGL_NO_SURFACE;
+}
+
+EGLDisplay CWinSystemDmxEGLContext::GetEGLDisplay() const
+{
+  return m_eglContext.GetEGLDisplay();
+}
+
+EGLSurface CWinSystemDmxEGLContext::GetEGLSurface() const
+{
+  return m_eglContext.GetEGLSurface();
+}
+
+EGLContext CWinSystemDmxEGLContext::GetEGLContext() const
+{
+  return m_eglContext.GetEGLContext();
+}
+
+EGLConfig CWinSystemDmxEGLContext::GetEGLConfig() const
+{
+  return m_eglContext.GetEGLConfig();
+}
+
+bool CWinSystemDmxEGLContext::InitWindowSystemEGL(EGLint renderableType, EGLint apiType)
+{
+  m_eglDisplay = EGL_DEFAULT_DISPLAY;
+
+  if (!CWinSystemDmx::InitWindowSystem())
+  {
+    return false;
+  }
+
+  if (!m_eglContext.CreateDisplay(m_eglDisplay))
+  {
+    return false;
+  }
+
+  if (!m_eglContext.InitializeDisplay(apiType))
+  {
+    return false;
+  }
+
+  if (!m_eglContext.ChooseConfig(renderableType))
+  {
+    return false;
+  }
+
+  if (!CreateContext())
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CWinSystemDmxEGLContext::CreateNewWindow(const std::string& name,
+                                              bool fullScreen,
+                                              RESOLUTION_INFO& res)
+{
+  if (!DestroyWindow())
+  {
+    return false;
+  }
+
+  if (!m_DMX->IsCurrentResolution(res))
+  {
+    //Notify other subsystems that we change resolution
+    OnLostDevice();
+
+    if (!m_DMX->SetResolution(res))
+    {
+      CLog::Log(LOGERROR, "CWinSystemDmxEGLContext::{} - failed to set mode", __FUNCTION__);
+      return false;
+    }
+  }
+
+  if (!m_DMX->OpenDisplay())
+  {
+    return false;
+  }
+
+  if (m_eglSurface == EGL_NO_SURFACE)
+  {
+    m_eglSurface = static_cast<EGLNativeWindowType>(new EGL_DISPMANX_WINDOW_T);
+    if (!m_DMX->CreateSurface(m_eglSurface, res))
+    {
+      CLog::Log(LOGERROR, "CWinSystemDmxEGLContext::{} - failed to create dispmanx surface",
+                __FUNCTION__);
+      return false;
+    }
+  }
+
+  if (!m_eglContext.CreateSurface(m_eglSurface))
+  {
+    CLog::Log(LOGERROR, "CWinSystemDmxEGLContext::{} - failed to create egl surface", __FUNCTION__);
+    return false;
+  }
+
+  if (!m_eglContext.BindContext())
+  {
+    return false;
+  }
+
+  m_bFullScreen = fullScreen;
+  m_nWidth = res.iWidth;
+  m_nHeight = res.iHeight;
+  m_fRefreshRate = res.fRefreshRate;
+  m_bWindowCreated = true;
+
+  return true;
+}
+
+bool CWinSystemDmxEGLContext::DestroyWindow()
+{
+  m_eglContext.DestroySurface();
+  if (m_eglSurface != EGL_NO_SURFACE)
+  {
+    m_DMX->DestroySurface();
+    m_eglSurface = EGL_NO_SURFACE;
+    m_DMX->CloseDisplay();
+  }
+  m_bWindowCreated = false;
+  return true;
+}
+
+bool CWinSystemDmxEGLContext::DestroyWindowSystem()
+{
+  CDVDFactoryCodec::ClearHWAccels();
+  VIDEOPLAYER::CRendererFactory::ClearRenderer();
+  m_eglContext.Destroy();
+
+  return CWinSystemDmx::DestroyWindowSystem();
+}
\ No newline at end of file
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.h xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxEGLContext.h	2023-03-31 10:14:27.000000000 +0000
@@ -0,0 +1,55 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "WinSystemDmx.h"
+#include "utils/EGLUtils.h"
+
+#include <memory>
+
+namespace KODI
+{
+namespace WINDOWING
+{
+namespace DMX
+{
+
+class CWinSystemDmxEGLContext : public CWinSystemDmx
+{
+public:
+  CWinSystemDmxEGLContext();
+
+  ~CWinSystemDmxEGLContext() override = default;
+
+  bool DestroyWindowSystem() override;
+  bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res) override;
+  bool DestroyWindow() override;
+
+  EGLDisplay GetEGLDisplay() const;
+  EGLSurface GetEGLSurface() const;
+  EGLContext GetEGLContext() const;
+  EGLConfig GetEGLConfig() const;
+
+protected:
+  /**
+   * Inheriting classes should override InitWindowSystem() without parameters
+   * and call this function there with appropriate parameters
+   */
+  bool InitWindowSystemEGL(EGLint renderableType, EGLint apiType);
+  virtual bool CreateContext() = 0;
+
+  CEGLContextUtils m_eglContext;
+
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+};
+
+} // namespace DMX
+} // namespace WINDOWING
+} // namespace KODI
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.cpp xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.cpp	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.cpp	2023-04-09 17:06:21.830572778 +0000
@@ -0,0 +1,166 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemDmxGLESContext.h"
+
+#include "application/Application.h"
+#include "application/ApplicationPlayer.h"
+#include "application/ApplicationPowerHandling.h"
+#include "cores/DataCacheCore.h"
+#include "cores/RetroPlayer/process/dmx/RPProcessInfoDmx.h"
+#include "cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpegMMAL.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMMAL.h"
+#include "cores/VideoPlayer/Process/dmx/ProcessInfoDmx.h"
+#include "cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMMAL.h"
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIDialog.h"
+#include "guilib/GUIWindowManager.h"
+#include "rendering/gles/ScreenshotSurfaceGLES.h"
+#include "utils/BufferObjectFactory.h"
+#include "utils/UDMABufferObject.h"
+#include "utils/XTimeUtils.h"
+#include "utils/log.h"
+#include "windowing/WindowSystemFactory.h"
+
+using namespace KODI::WINDOWING::DMX;
+
+using namespace std::chrono_literals;
+
+void CWinSystemDmxGLESContext::Register()
+{
+  CWindowSystemFactory::RegisterWindowSystem(CreateWinSystem, "dmx");
+}
+
+std::unique_ptr<CWinSystemBase> CWinSystemDmxGLESContext::CreateWinSystem()
+{
+  return std::make_unique<CWinSystemDmxGLESContext>();
+}
+
+bool CWinSystemDmxGLESContext::InitWindowSystem()
+{
+  if (!CWinSystemDmxEGLContext::InitWindowSystemEGL(EGL_OPENGL_ES2_BIT, EGL_OPENGL_ES_API))
+  {
+    return false;
+  }
+  RETRO::CRPProcessInfoDmx::Register();
+  RETRO::CRPProcessInfoDmx::RegisterRendererFactory(new RETRO::CRendererFactoryOpenGLES);
+  CDVDFactoryCodec::ClearHWAccels();
+  MMAL::CDVDVideoCodecMMAL::Register();
+  MMAL::CDVDVideoCodecFFmpegMMAL::Register();
+  VIDEOPLAYER::CRendererFactory::ClearRenderer();
+  CLinuxRendererGLES::Register();
+  MMAL::CRendererMMAL::Register();
+  VIDEOPLAYER::CProcessInfoDmx::Register();
+
+  CScreenshotSurfaceGLES::Register();
+
+  return true;
+}
+
+bool CWinSystemDmxGLESContext::SetFullScreen(bool fullScreen,
+                                             RESOLUTION_INFO& res,
+                                             bool blankOtherDisplays)
+{
+  if (res.iWidth != m_nWidth || res.iHeight != m_nHeight)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemDmxGLESContext::{} - resolution changed, creating a new window",
+              __FUNCTION__);
+    CreateNewWindow("", fullScreen, res);
+  }
+
+  if (!m_eglContext.TrySwapBuffers())
+  {
+    CEGLUtils::Log(LOGERROR, "eglSwapBuffers failed");
+    throw std::runtime_error("eglSwapBuffers failed");
+  }
+
+  if (CWinSystemDmx::SetFullScreen(fullScreen, res, blankOtherDisplays))
+  {
+    return CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight);
+  }
+}
+
+bool CWinSystemDmxGLESContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  if (CWinSystemDmx::ResizeWindow(newWidth, newHeight, newLeft, newTop))
+  {
+    return CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight);
+  }
+  return false;
+}
+
+void CWinSystemDmxGLESContext::PresentRender(bool rendered, bool videoLayer)
+{
+  if (!m_bVsyncInit)
+    SetVSync(true);
+
+  if (!m_bRenderCreated)
+    return;
+
+  if (rendered || videoLayer)
+  {
+    if (rendered)
+    {
+      if (!m_eglContext.TrySwapBuffers())
+      {
+        CEGLUtils::Log(LOGERROR, "eglSwapBuffers failed");
+        throw std::runtime_error("eglSwapBuffers failed");
+      }
+      if (!m_visible && CServiceBroker::GetGUI()->GetWindowManager().HasVisibleControls())
+      {
+        if (m_DMX->SetVisibility(true))
+          m_visible = true;
+      }
+    }
+    else if (videoLayer && !CServiceBroker::GetGUI()->GetWindowManager().HasVisibleControls())
+    {
+      if (!m_visible)
+        KODI::TIME::Sleep(10ms);
+      else if (m_DMX->SetVisibility(false))
+        m_visible = false;
+    }
+
+    if (m_dispReset && m_dispResetTimer.IsTimePast())
+    {
+      CLog::Log(LOGDEBUG, "CWinSystemDmxGLESContext::{} - sending display reset to all clients",
+                __FUNCTION__);
+      m_dispReset = false;
+      std::unique_lock<CCriticalSection> lock(m_resourceSection);
+
+      for (auto resource : m_resources)
+        resource->OnResetDisplay();
+    }
+  }
+  else
+  {
+    KODI::TIME::Sleep(10ms);
+  }
+}
+
+bool CWinSystemDmxGLESContext::CreateContext()
+{
+  CEGLAttributesVec contextAttribs;
+  contextAttribs.Add({{EGL_CONTEXT_CLIENT_VERSION, 2}});
+
+  if (!m_eglContext.CreateContext(contextAttribs))
+  {
+    CLog::Log(LOGERROR, "EGL context creation failed");
+    return false;
+  }
+  return true;
+}
+
+void CWinSystemDmxGLESContext::SetVSyncImpl(bool enable)
+{
+  if (!m_eglContext.SetVSync(enable))
+    CLog::Log(LOGERROR, "Could not set egl vsync");
+}
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.h xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmxGLESContext.h	2023-04-04 16:00:02.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "WinSystemDmxEGLContext.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "utils/EGLUtils.h"
+
+#include <memory>
+
+class CVaapiProxy;
+
+namespace KODI
+{
+namespace WINDOWING
+{
+namespace DMX
+{
+
+class CWinSystemDmxGLESContext : public CWinSystemDmxEGLContext, public CRenderSystemGLES
+{
+public:
+  CWinSystemDmxGLESContext() = default;
+  ~CWinSystemDmxGLESContext() override = default;
+
+  static void Register();
+  static std::unique_ptr<CWinSystemBase> CreateWinSystem();
+
+  // Implementation of CWinSystemBase via CWinSystemDmx
+  CRenderSystemBase* GetRenderSystem() override { return this; }
+
+  bool InitWindowSystem() override;
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+  void PresentRender(bool rendered, bool videoLayer) override;
+
+protected:
+  void SetVSyncImpl(bool enable) override;
+  void PresentRenderImpl(bool rendered) override{};
+  bool CreateContext() override;
+
+private:
+  uint64_t m_sequence{0};
+};
+
+} // namespace DMX
+} // namespace WINDOWING
+} // namespace KODI
diff --no-dereference -ruN xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmx.h xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmx.h
--- xbmc-20.1-Nexus/xbmc/windowing/dmx/WinSystemDmx.h	1970-01-01 00:00:00.000000000 +0000
+++ xbmc-test-Nexus/xbmc/windowing/dmx/WinSystemDmx.h	2023-04-08 14:51:30.919593943 +0000
@@ -0,0 +1,99 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "settings/Settings.h"
+#include "threads/CriticalSection.h"
+#include "threads/SystemClock.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/WinSystem.h"
+#include "windowing/dmx/DmxUtils.h"
+
+#include "platform/linux/input/LibInputHandler.h"
+
+#include <utility>
+
+class IDispResource;
+
+namespace KODI
+{
+namespace WINDOWING
+{
+namespace DMX
+{
+
+class CWinSystemDmx : public CWinSystemBase
+{
+public:
+  CWinSystemDmx();
+  ~CWinSystemDmx() override = default;
+
+  const std::string GetName() override { return "dmx"; }
+
+  bool InitWindowSystem() override;
+  bool DestroyWindowSystem() override;
+
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+
+  bool DisplayHardwareScalingEnabled() override;
+  void UpdateDisplayHardwareScaling(const RESOLUTION_INFO& resInfo) override;
+
+  bool CanDoWindowed() override { return false; }
+  void UpdateResolutions() override;
+
+  bool UseLimitedColor() override;
+
+  bool Hide() override;
+  bool Show(bool raise = true) override;
+
+  void Register(IDispResource* resource) override;
+  void Unregister(IDispResource* resource) override;
+  int NoOfBuffers() override { return 2; }
+
+  uint64_t WaitVerticalSync(uint64_t sequence, uint32_t wait_ms = 0)
+  {
+    return m_DMX->WaitVerticalSync(sequence, nullptr, wait_ms);
+  }
+
+  uint64_t WaitVerticalSync(uint64_t sequence, uint64_t* time, uint32_t wait_ms = 0)
+  {
+    return m_DMX->WaitVerticalSync(sequence, time, wait_ms);
+  }
+
+  bool ReadPixels(int32_t x,
+                  int32_t y,
+                  int32_t width,
+                  int32_t height,
+                  uint32_t format,
+                  bool swap,
+                  void* pixels);
+
+  std::unique_ptr<CVideoSync> GetVideoSync(void* clock) override;
+
+protected:
+  void OnLostDevice();
+
+  std::unique_ptr<CDmxUtils> m_DMX;
+
+  CCriticalSection m_resourceSection;
+  std::vector<IDispResource*> m_resources;
+
+  bool m_dispReset;
+  XbmcThreads::EndTime<> m_dispResetTimer;
+
+  bool m_visible;
+
+  std::shared_ptr<CSettings> m_settings;
+  std::unique_ptr<CLibInputHandler> m_libinput;
+};
+
+} // namespace DMX
+} // namespace WINDOWING
+} // namespace KODI
